<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generalization · d2l Julia</title><meta name="title" content="Generalization · d2l Julia"/><meta property="og:title" content="Generalization · d2l Julia"/><meta property="twitter:title" content="Generalization · d2l Julia"/><meta name="description" content="Documentation for d2l Julia."/><meta property="og:description" content="Documentation for d2l Julia."/><meta property="twitter:description" content="Documentation for d2l Julia."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../LNN_1/">d2l Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Linear Neural Networks for Regression</span><ul><li><a class="tocitem" href="../LNN_1/">Linear Regression</a></li><li><a class="tocitem" href="../LNN_2/">Multiple Dispatch Design for Implementation</a></li><li><a class="tocitem" href="../LNN_3/">Synthetic Regression Data</a></li><li><a class="tocitem" href="../LNN_4/">Linear Regression Implementation from Scratch</a></li><li><a class="tocitem" href="../LNN_5/">Concise Implementation of Linear Regression</a></li><li class="is-active"><a class="tocitem" href>Generalization</a><ul class="internal"><li><a class="tocitem" href="#Training-Error-and-Generalization-Error"><span>Training Error and Generalization Error</span></a></li><li><a class="tocitem" href="#Underfitting-or-Overfitting?"><span>Underfitting or Overfitting?</span></a></li><li><a class="tocitem" href="#Model-Selection"><span>Model Selection</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li><li><a class="tocitem" href="#Exercises"><span>Exercises</span></a></li></ul></li><li><a class="tocitem" href="../LNN_7/">Weight Decay</a></li></ul></li><li><span class="tocitem">Linear Neural Networks for Classification</span><ul><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_1/">Softmax Regression</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_2/">The Image Classification Dataset</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_3/">Softmax Regression Implementation from Scratch</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_4/">Concise Implementation of Softmax Regression</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_5/">Generalization in Classification</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_6/">Environment and Distribution Shift</a></li></ul></li><li><span class="tocitem">Multilayer Perceptron</span><ul><li><a class="tocitem" href="../../CH5.MLP/MLP_1/">Multilayer Perceptrons</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_2/">Implementation of Multilayer Perceptrons</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_3/">Forward Propagation, Backward Propagation, and Computational Graphs</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_4/">Numerical Stability and Initialization</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_5/">Generalization in Deep Learning</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_6/">Dropout</a></li></ul></li><li><span class="tocitem">Convolutional Neural Networks</span><ul><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_2/">Convolutions for Images</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_3/">Padding and Stride</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_4/">Multiple Input and Multiple Output Channels</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_5/">Pooling</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_6/">Convolutional Neural Networks (LeNet)</a></li></ul></li><li><span class="tocitem">Modern Convolutional Neural Networks</span><ul><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_0/">Modern Convolutional Neural Networks</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_1/">Deep Convolutional Neural Networks (AlexNet)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_2/">Networks Using Blocks (VGG)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_3/">-</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_4/">Multi-Branch Networks  (GoogLeNet)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_5/">-</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_6/">Residual Networks (ResNet) and ResNeXt</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_7/">Densely Connected Networks (DenseNet)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_8/">Designing Convolution Network Architectures</a></li></ul></li><li><span class="tocitem">Recurrent Neural Networks</span><ul><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_0/">Recurrent Neural Networks</a></li><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_1/">Working with Sequences</a></li><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_2/">Converting Raw Text into Sequence Data</a></li><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_3/">Language Models</a></li><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_4/">Recurrent Neural Networks</a></li><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_5/">Recurrent Neural Network Implementation from Scratch</a></li><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_6/">Concise Implementation of Recurrent Neural Networks</a></li><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_7/">Backpropagation Through Time</a></li></ul></li><li><span class="tocitem">Modern Recurrent Neural Networks</span><ul><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN7/">Sequence-to-Sequence Learning for Machine Translation</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_1/">Long Short-Term Memory (LSTM)</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_2/">Gated Recurrent Units (GRU)</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_3/">-</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_4/">Bidirectional Recurrent Neural Networks</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_5/">Machine Translation and the Dataset</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_6/">The Encoder–Decoder Architecture</a></li></ul></li><li><span class="tocitem">Attention Mechanisms and Transformers</span><ul><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_1/">Queries, Keys, and Values</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_2/">Attention Pooling by Similarity</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_3/">Attention Scoring Functions</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_4/">The Bahdanau Attention Mechanism</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_5/">Multi-Head Attention</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_6/">Self-Attention and Positional Encoding</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/Untitled/">-</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Linear Neural Networks for Regression</a></li><li class="is-active"><a href>Generalization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Generalization</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Generalization"><a class="docs-heading-anchor" href="#Generalization">Generalization</a><a id="Generalization-1"></a><a class="docs-heading-anchor-permalink" href="#Generalization" title="Permalink"></a></h1><p>:label:<code>sec_generalization_basics</code></p><p>Consider two college students diligently preparing for their final exam. Commonly, this preparation will consist of practicing and testing their abilities by taking exams administered in previous years. Nonetheless, doing well on past exams is no guarantee that they will excel when it matters. For instance, imagine a student, Extraordinary Ellie, whose preparation consisted entirely of memorizing the answers to previous years&#39; exam questions. Even if Ellie were endowed with an extraordinary memory, and thus could perfectly recall the answer to any <em>previously seen</em> question, she might nevertheless freeze when faced with a new (<em>previously unseen</em>) question. By comparison, imagine another student, Inductive Irene, with comparably poor memorization skills, but a knack for picking up patterns. Note that if the exam truly consisted of recycled questions from a previous year, Ellie would handily outperform Irene. Even if Irene&#39;s inferred patterns yielded 90% accurate predictions, they could never compete with Ellie&#39;s 100% recall. However, even if the exam consisted entirely of fresh questions, Irene might maintain her 90% average.</p><p>As machine learning scientists, our goal is to discover <em>patterns</em>. But how can we be sure that we have truly discovered a <em>general</em> pattern and not simply memorized our data? Most of the time, our predictions are only useful if our model discovers such a pattern. We do not want to predict yesterday&#39;s stock prices, but tomorrow&#39;s. We do not need to recognize already diagnosed diseases for previously seen patients, but rather previously undiagnosed ailments in previously unseen patients. This problem–-how to discover patterns that <em>generalize</em>–-is the fundamental problem of machine learning, and arguably of all of statistics. We might cast this problem as just one slice of a far grander question that engulfs all of science: when are we ever justified in making the leap from particular observations to more general statements?</p><p>In real life, we must fit our models using a finite collection of data. The typical scales of that data vary wildly across domains. For many important medical problems, we can only access a few thousand data points. When studying rare diseases, we might be lucky to access hundreds. By contrast, the largest public datasets consisting of labeled photographs, e.g., ImageNet :cite:<code>Deng.Dong.Socher.ea.2009</code>, contain millions of images. And some unlabeled image collections such as the Flickr YFC100M dataset can be even larger, containing over 100 million images :cite:<code>thomee2016yfcc100m</code>. However, even at this extreme scale, the number of available data points remains infinitesimally small compared to the space of all possible images at a megapixel resolution. Whenever we work with finite samples, we must keep in mind the risk that we might fit our training data, only to discover that we failed to discover a generalizable pattern.</p><p>The phenomenon of fitting closer to our training data than to the underlying distribution is called <em>overfitting</em>, and techniques for combatting overfitting are often called <em>regularization</em> methods. While it is no substitute for a proper introduction to statistical learning theory (see :citet:<code>Vapnik98,boucheron2005theory</code>), we will give you just enough intuition to get going. We will revisit generalization in many chapters throughout the book, exploring both what is known about the principles underlying generalization in various models, and also heuristic techniques that have been found (empirically) to yield improved generalization on tasks of practical interest.</p><h2 id="Training-Error-and-Generalization-Error"><a class="docs-heading-anchor" href="#Training-Error-and-Generalization-Error">Training Error and Generalization Error</a><a id="Training-Error-and-Generalization-Error-1"></a><a class="docs-heading-anchor-permalink" href="#Training-Error-and-Generalization-Error" title="Permalink"></a></h2><p>In the standard supervised learning setting, we assume that the training data and the test data are drawn <em>independently</em> from <em>identical</em> distributions. This is commonly called the <em>IID assumption</em>. While this assumption is strong, it is worth noting that, absent any such assumption, we would be dead in the water. Why should we believe that training data sampled from distribution <span>$P(X,Y)$</span> should tell us how to make predictions on test data generated by a <em>different distribution</em> <span>$Q(X,Y)$</span>? Making such leaps turns out to require strong assumptions about how <span>$P$</span> and <span>$Q$</span> are related. Later on we will discuss some assumptions that allow for shifts in distribution but first we need to understand the IID case, where <span>$P(\cdot) = Q(\cdot)$</span>.</p><p>To begin with, we need to differentiate between the <em>training error</em> <span>$R_\textrm{emp}$</span>, which is a <em>statistic</em> calculated on the training dataset, and the <em>generalization error</em> <span>$R$</span>, which is an <em>expectation</em> taken with respect to the underlying distribution. You can think of the generalization error as what you would see  if you applied your model to an infinite stream of additional data examples drawn from the same underlying data distribution. Formally the training error is expressed as a <em>sum</em> (with the same notation as :numref:<code>sec_linear_regression</code>):</p><p class="math-container">\[R_\textrm{emp}[\mathbf{X}, \mathbf{y}, f] = \frac{1}{n} \sum_{i=1}^n l(\mathbf{x}^{(i)}, y^{(i)}, f(\mathbf{x}^{(i)})),\]</p><p>while the generalization error is expressed as an integral:</p><p class="math-container">\[R[p, f] = E_{(\mathbf{x}, y) \sim P} [l(\mathbf{x}, y, f(\mathbf{x}))] =
\int \int l(\mathbf{x}, y, f(\mathbf{x})) p(\mathbf{x}, y) \;d\mathbf{x} dy.\]</p><p>Problematically, we can never calculate the generalization error <span>$R$</span> exactly. Nobody ever tells us the precise form of the density function <span>$p(\mathbf{x}, y)$</span>. Moreover, we cannot sample an infinite stream of data points. Thus, in practice, we must <em>estimate</em> the generalization error by applying our model to an independent test set constituted of a random selection of examples <span>$\mathbf{X}&#39;$</span> and labels <span>$\mathbf{y}&#39;$</span> that were withheld from our training set. This consists of applying the same formula that was used for calculating the empirical training error but to a test set <span>$\mathbf{X}&#39;, \mathbf{y}&#39;$</span>.</p><p>Crucially, when we evaluate our classifier on the test set, we are working with a <em>fixed</em> classifier (it does not depend on the sample of the test set), and thus estimating its error is simply the problem of mean estimation. However the same cannot be said for the training set. Note that the model we wind up with depends explicitly on the selection of the training set and thus the training error will in general be a biased estimate of the true error on the underlying population. The central question of generalization is then when should we expect our training error to be close to the population error (and thus the generalization error).</p><h3 id="Model-Complexity"><a class="docs-heading-anchor" href="#Model-Complexity">Model Complexity</a><a id="Model-Complexity-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Complexity" title="Permalink"></a></h3><p>In classical theory, when we have simple models and abundant data, the training and generalization errors tend to be close. However, when we work with more complex models and/or fewer examples, we expect the training error to go down but the generalization gap to grow. This should not be surprising. Imagine a model class so expressive that for any dataset of <span>$n$</span> examples, we can find a set of parameters that can perfectly fit arbitrary labels, even if randomly assigned. In this case, even if we fit our training data perfectly, how can we conclude anything about the generalization error? For all we know, our generalization error might be no better than random guessing.</p><p>In general, absent any restriction on our model class, we cannot conclude, based on fitting the training data alone, that our model has discovered any generalizable pattern :cite:<code>vapnik1994measuring</code>. On the other hand, if our model class was not capable of fitting arbitrary labels, then it must have discovered a pattern. Learning-theoretic ideas about model complexity derived some inspiration from the ideas of Karl Popper, an influential philosopher of science, who formalized the criterion of falsifiability. According to Popper, a theory that can explain any and all observations is not a scientific theory at all! After all, what has it told us about the world if it has not ruled out any possibility? In short, what we want is a hypothesis that <em>could not</em> explain any observations we might conceivably make and yet nevertheless happens to be compatible with those observations that we <em>in fact</em> make.</p><p>Now what precisely constitutes an appropriate notion of model complexity is a complex matter. Often, models with more parameters are able to fit a greater number of arbitrarily assigned labels. However, this is not necessarily true. For instance, kernel methods operate in spaces with infinite numbers of parameters, yet their complexity is controlled by other means :cite:<code>Scholkopf.Smola.2002</code>. One notion of complexity that often proves useful is the range of values that the parameters can take. Here, a model whose parameters are permitted to take arbitrary values would be more complex. We will revisit this idea in the next section, when we introduce <em>weight decay</em>, your first practical regularization technique. Notably, it can be difficult to compare complexity among members of substantially different model classes (say, decision trees vs. neural networks).</p><p>At this point, we must stress another important point that we will revisit when introducing deep neural networks. When a model is capable of fitting arbitrary labels, low training error does not necessarily imply low generalization error. <em>However, it does not necessarily imply high generalization error either!</em> All we can say with confidence is that low training error alone is not enough to certify low generalization error. Deep neural networks turn out to be just such models: while they generalize well in practice, they are too powerful to allow us to conclude much on the basis of training error alone. In these cases we must rely more heavily on our holdout data to certify generalization after the fact. Error on the holdout data, i.e., validation set, is called the <em>validation error</em>.</p><h2 id="Underfitting-or-Overfitting?"><a class="docs-heading-anchor" href="#Underfitting-or-Overfitting?">Underfitting or Overfitting?</a><a id="Underfitting-or-Overfitting?-1"></a><a class="docs-heading-anchor-permalink" href="#Underfitting-or-Overfitting?" title="Permalink"></a></h2><p>When we compare the training and validation errors, we want to be mindful of two common situations. First, we want to watch out for cases when our training error and validation error are both substantial but there is a little gap between them. If the model is unable to reduce the training error, that could mean that our model is too simple (i.e., insufficiently expressive) to capture the pattern that we are trying to model. Moreover, since the <em>generalization gap</em> (<span>$R_\textrm{emp} - R$</span>) between our training and generalization errors is small, we have reason to believe that we could get away with a more complex model. This phenomenon is known as <em>underfitting</em>.</p><p>On the other hand, as we discussed above, we want to watch out for the cases when our training error is significantly lower than our validation error, indicating severe <em>overfitting</em>. Note that overfitting is not always a bad thing. In deep learning especially, the best predictive models often perform far better on training data than on holdout data. Ultimately, we usually care about driving the generalization error lower, and only care about the gap insofar as it becomes an obstacle to that end. Note that if the training error is zero, then the generalization gap is precisely equal to the generalization error and we can make progress only by reducing the gap.</p><h3 id="Polynomial-Curve-Fitting"><a class="docs-heading-anchor" href="#Polynomial-Curve-Fitting">Polynomial Curve Fitting</a><a id="Polynomial-Curve-Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-Curve-Fitting" title="Permalink"></a></h3><p>:label:<code>subsec_polynomial-curve-fitting</code></p><p>To illustrate some classical intuition about overfitting and model complexity, consider the following: given training data consisting of a single feature <span>$x$</span> and a corresponding real-valued label <span>$y$</span>, we try to find the polynomial of degree <span>$d$</span></p><p class="math-container">\[\hat{y}= \sum_{i=0}^d x^i w_i\]</p><p>for estimating the label <span>$y$</span>. This is just a linear regression problem where our features are given by the powers of <span>$x$</span>, the model&#39;s weights are given by <span>$w_i$</span>, and the bias is given by <span>$w_0$</span> since <span>$x^0 = 1$</span> for all <span>$x$</span>. Since this is just a linear regression problem, we can use the squared error as our loss function.</p><p>A higher-order polynomial function is more complex than a lower-order polynomial function, since the higher-order polynomial has more parameters and the model function&#39;s selection range is wider. Fixing the training dataset, higher-order polynomial functions should always achieve lower (at worst, equal) training error relative to lower-degree polynomials. In fact, whenever each data example has a distinct value of <span>$x$</span>, a polynomial function with degree equal to the number of data examples can fit the training set perfectly. We compare the relationship between polynomial degree (model complexity) and both underfitting and overfitting in :numref:<code>fig_capacity_vs_error</code>.</p><p><img src="../../img/capacity-vs-error.svg" alt="Influence of model complexity on underfitting and overfitting."/> :label:<code>fig_capacity_vs_error</code></p><h3 id="Dataset-Size"><a class="docs-heading-anchor" href="#Dataset-Size">Dataset Size</a><a id="Dataset-Size-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-Size" title="Permalink"></a></h3><p>As the above bound already indicates, another big consideration to bear in mind is dataset size. Fixing our model, the fewer samples we have in the training dataset, the more likely (and more severely) we are to encounter overfitting. As we increase the amount of training data, the generalization error typically decreases. Moreover, in general, more data never hurts. For a fixed task and data distribution, model complexity should not increase more rapidly than the amount of data. Given more data, we might  attempt to fit a more complex model. Absent sufficient data, simpler models may be more difficult to beat. For many tasks, deep learning only outperforms linear models when many thousands of training examples are available. In part, the current success of deep learning owes considerably to the abundance of massive datasets arising from Internet companies, cheap storage, connected devices, and the broad digitization of the economy.</p><h2 id="Model-Selection"><a class="docs-heading-anchor" href="#Model-Selection">Model Selection</a><a id="Model-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Selection" title="Permalink"></a></h2><p>:label:<code>subsec_generalization-model-selection</code></p><p>Typically, we select our final model only after evaluating multiple models that differ in various ways (different architectures, training objectives, selected features, data preprocessing, learning rates, etc.). Choosing among many models is aptly called <em>model selection</em>.</p><p>In principle, we should not touch our test set until after we have chosen all our hyperparameters. Were we to use the test data in the model selection process, there is a risk that we might overfit the test data. Then we would be in serious trouble. If we overfit our training data, there is always the evaluation on test data to keep us honest. But if we overfit the test data, how would we ever know? See :citet:<code>ong2005learning</code> for an example of how this can lead to absurd results even for models where the complexity can be tightly controlled.</p><p>Thus, we should never rely on the test data for model selection. And yet we cannot rely solely on the training data for model selection either because we cannot estimate the generalization error on the very data that we use to train the model.</p><p>In practical applications, the picture gets muddier. While ideally we would only touch the test data once, to assess the very best model or to compare a small number of models with each other, real-world test data is seldom discarded after just one use. We can seldom afford a new test set for each round of experiments. In fact, recycling benchmark data for decades can have a significant impact on the development of algorithms, e.g., for <a href="https://paperswithcode.com/sota/image-classification-on-imagenet">image classification</a> and <a href="https://paperswithcode.com/sota/image-classification-on-mnist">optical character recognition</a>.</p><p>The common practice for addressing the problem of <em>training on the test set</em> is to split our data three ways, incorporating a <em>validation set</em> in addition to the training and test datasets. The result is a murky business where the boundaries between validation and test data are worryingly ambiguous. Unless explicitly stated otherwise, in the experiments in this book we are really working with what should rightly be called training data and validation data, with no true test sets. Therefore, the accuracy reported in each experiment of the book is really the validation accuracy and not a true test set accuracy.</p><h3 id="Cross-Validation"><a class="docs-heading-anchor" href="#Cross-Validation">Cross-Validation</a><a id="Cross-Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-Validation" title="Permalink"></a></h3><p>When training data is scarce, we might not even be able to afford to hold out enough data to constitute a proper validation set. One popular solution to this problem is to employ <span>$K$</span><em>-fold cross-validation</em>. Here, the original training data is split into <span>$K$</span> non-overlapping subsets. Then model training and validation are executed <span>$K$</span> times, each time training on <span>$K-1$</span> subsets and validating on a different subset (the one not used for training in that round). Finally, the training and validation errors are estimated by averaging over the results from the <span>$K$</span> experiments.</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>This section explored some of the  underpinnings of generalization in  machine learning. Some of these ideas become complicated and counterintuitive when we get to deeper models; here, models are capable of overfitting data badly, and the relevant notions of complexity can be both implicit and counterintuitive (e.g., larger architectures with more parameters generalizing better). We leave you with a few rules of thumb:</p><ol><li>Use validation sets (or <span>$K$</span><em>-fold cross-validation</em>) for model selection;</li><li>More complex models often require more data;</li><li>Relevant notions of complexity include both the number of parameters and the range of values that they are allowed to take;</li><li>Keeping all else equal, more data almost always leads to better generalization;</li><li>This entire talk of generalization is all predicated on the IID assumption. If we relax this assumption, allowing for distributions to shift between the train and testing periods, then we cannot say anything about generalization absent a further (perhaps milder) assumption.</li></ol><h2 id="Exercises"><a class="docs-heading-anchor" href="#Exercises">Exercises</a><a id="Exercises-1"></a><a class="docs-heading-anchor-permalink" href="#Exercises" title="Permalink"></a></h2><ol><li>When can you solve the problem of polynomial regression exactly?</li><li>Give at least five examples where dependent random variables make treating the problem as IID data inadvisable.</li><li>Can you ever expect to see zero training error? Under which circumstances would you see zero generalization error?</li><li>Why is <span>$K$</span>-fold cross-validation very expensive to compute?</li><li>Why is the <span>$K$</span>-fold cross-validation error estimate biased?</li><li>The VC dimension is defined as the maximum number of points that can be classified with arbitrary labels <span>$\{\pm 1\}$</span> by a function of a class of functions. Why might this not be a good idea for measuring how complex the class of functions is? Hint: consider the magnitude of the functions.</li><li>Your manager gives you a difficult dataset on which your current algorithm does not perform so well. How would you justify to him that you need more data? Hint: you cannot increase the data but you can decrease it.</li></ol><p>:begin<em>tab:<code>mxnet</code> <a href="https://discuss.d2l.ai/t/96">Discussions</a> :end</em>tab:</p><p>:begin<em>tab:<code>pytorch</code> <a href="https://discuss.d2l.ai/t/97">Discussions</a> :end</em>tab:</p><p>:begin<em>tab:<code>tensorflow</code> <a href="https://discuss.d2l.ai/t/234">Discussions</a> :end</em>tab:</p><p>:begin<em>tab:<code>jax</code> <a href="https://discuss.d2l.ai/t/17978">Discussions</a> :end</em>tab:</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../LNN_5/">« Concise Implementation of Linear Regression</a><a class="docs-footer-nextpage" href="../LNN_7/">Weight Decay »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Sunday 15 June 2025 19:32">Sunday 15 June 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
