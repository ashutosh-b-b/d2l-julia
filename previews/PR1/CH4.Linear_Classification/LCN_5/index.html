<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generalization in Classification · d2l Julia</title><meta name="title" content="Generalization in Classification · d2l Julia"/><meta property="og:title" content="Generalization in Classification · d2l Julia"/><meta property="twitter:title" content="Generalization in Classification · d2l Julia"/><meta name="description" content="Documentation for d2l Julia."/><meta property="og:description" content="Documentation for d2l Julia."/><meta property="twitter:description" content="Documentation for d2l Julia."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../CH3.Linear_Regression/LNN_1/">d2l Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Linear Neural Networks for Regression</span><ul><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_1/">Linear Regression</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_2/">Multiple Dispatch Design for Implementation</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_3/">Synthetic Regression Data</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_4/">Linear Regression Implementation from Scratch</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_5/">Concise Implementation of Linear Regression</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_6/">Generalization</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_7/">Weight Decay</a></li></ul></li><li><span class="tocitem">Linear Neural Networks for Classification</span><ul><li><a class="tocitem" href="../LCN_1/">Softmax Regression</a></li><li><a class="tocitem" href="../LCN_2/">The Image Classification Dataset</a></li><li><a class="tocitem" href="../LCN_3/">Softmax Regression Implementation from Scratch</a></li><li><a class="tocitem" href="../LCN_4/">Concise Implementation of Softmax Regression</a></li><li class="is-active"><a class="tocitem" href>Generalization in Classification</a><ul class="internal"><li><a class="tocitem" href="#The-Test-Set"><span>The Test Set</span></a></li><li><a class="tocitem" href="#Test-Set-Reuse"><span>Test Set Reuse</span></a></li><li><a class="tocitem" href="#Statistical-Learning-Theory"><span>Statistical Learning Theory</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li><li><a class="tocitem" href="#Exercises"><span>Exercises</span></a></li></ul></li><li><a class="tocitem" href="../LCN_6/">Environment and Distribution Shift</a></li></ul></li><li><span class="tocitem">Multilayer Perceptron</span><ul><li><a class="tocitem" href="../../CH5.MLP/MLP_1/">Multilayer Perceptrons</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_2/">Implementation of Multilayer Perceptrons</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_3/">Forward Propagation, Backward Propagation, and Computational Graphs</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_4/">Numerical Stability and Initialization</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_5/">Generalization in Deep Learning</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_6/">Dropout</a></li></ul></li><li><span class="tocitem">Convolutional Neural Networks</span><ul><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_2/">Convolutions for Images</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_3/">Padding and Stride</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_4/">Multiple Input and Multiple Output Channels</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_5/">Pooling</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_6/">Convolutional Neural Networks (LeNet)</a></li></ul></li><li><span class="tocitem">Modern Convolutional Neural Networks</span><ul><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_0/">Modern Convolutional Neural Networks</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_1/">Deep Convolutional Neural Networks (AlexNet)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_2/">Networks Using Blocks (VGG)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_3/">-</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_4/">Multi-Branch Networks  (GoogLeNet)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_5/">-</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_6/">Residual Networks (ResNet) and ResNeXt</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_7/">Densely Connected Networks (DenseNet)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_8/">Designing Convolution Network Architectures</a></li></ul></li><li><span class="tocitem">Recurrent Neural Networks</span><ul><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_0/">Recurrent Neural Networks</a></li><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_1/">Working with Sequences</a></li><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_2/">Converting Raw Text into Sequence Data</a></li><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_3/">Language Models</a></li><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_4/">Recurrent Neural Networks</a></li><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_5/">Recurrent Neural Network Implementation from Scratch</a></li><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_6/">Concise Implementation of Recurrent Neural Networks</a></li><li><a class="tocitem" href="../../CH8.Recurrent_Neural_Networks/RNN_7/">Backpropagation Through Time</a></li></ul></li><li><span class="tocitem">Modern Recurrent Neural Networks</span><ul><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN7/">Sequence-to-Sequence Learning for Machine Translation</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_1/">Long Short-Term Memory (LSTM)</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_2/">Gated Recurrent Units (GRU)</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_3/">-</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_4/">Bidirectional Recurrent Neural Networks</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_5/">Machine Translation and the Dataset</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_6/">The Encoder–Decoder Architecture</a></li></ul></li><li><span class="tocitem">Attention Mechanisms and Transformers</span><ul><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_1/">Queries, Keys, and Values</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_2/">Attention Pooling by Similarity</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_3/">Attention Scoring Functions</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_4/">The Bahdanau Attention Mechanism</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_5/">Multi-Head Attention</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_6/">Self-Attention and Positional Encoding</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/Untitled/">-</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Linear Neural Networks for Classification</a></li><li class="is-active"><a href>Generalization in Classification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Generalization in Classification</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Generalization-in-Classification"><a class="docs-heading-anchor" href="#Generalization-in-Classification">Generalization in Classification</a><a id="Generalization-in-Classification-1"></a><a class="docs-heading-anchor-permalink" href="#Generalization-in-Classification" title="Permalink"></a></h1><p>:label:<code>chap_classification_generalization</code></p><p>So far, we have focused on how to tackle multiclass classification problems by training (linear) neural networks with multiple outputs and softmax functions. Interpreting our model&#39;s outputs as probabilistic predictions, we motivated and derived the cross-entropy loss function, which calculates the negative log likelihood that our model (for a fixed set of parameters) assigns to the actual labels. And finally, we put these tools into practice by fitting our model to the training set. However, as always, our goal is to learn <em>general patterns</em>, as assessed empirically on previously unseen data (the test set). High accuracy on the training set means nothing. Whenever each of our inputs is unique (and indeed this is true for most high-dimensional datasets), we can attain perfect accuracy on the training set by just memorizing the dataset on the first training epoch, and subsequently looking up the label whenever we see a new image. And yet, memorizing the exact labels associated with the exact training examples does not tell us how to classify new examples. Absent further guidance, we might have to fall back on random guessing whenever we encounter new examples.</p><p>A number of burning questions demand immediate attention:</p><ol><li>How many test examples do we need to give a good estimate of the accuracy of our classifiers on the underlying population?</li><li>What happens if we keep evaluating models on the same test repeatedly?</li><li>Why should we expect that fitting our linear models to the training set should fare any better than our naive memorization scheme?</li></ol><p>Whereas :numref:<code>sec_generalization_basics</code> introduced the basics of overfitting and generalization in the context of linear regression, this chapter will go a little deeper, introducing some of the foundational ideas of statistical learning theory. It turns out that we often can guarantee generalization <em>a priori</em>: for many models, and for any desired upper bound on the generalization gap <span>$\epsilon$</span>, we can often determine some required number of samples <span>$n$</span> such that if our training set contains at least <span>$n$</span> samples, our empirical error will lie within <span>$\epsilon$</span> of the true error, <em>for any data generating distribution</em>. Unfortunately, it also turns out that while these sorts of guarantees provide a profound set of intellectual building blocks, they are of limited practical utility to the deep learning practitioner. In short, these guarantees suggest that ensuring generalization of deep neural networks <em>a priori</em> requires an absurd number of examples (perhaps trillions or more), even when we find that, on the tasks we care about, deep neural networks typically generalize remarkably well with far fewer examples (thousands). Thus deep learning practitioners often forgo <em>a priori</em> guarantees altogether, instead employing methods that have generalized well on similar problems in the past, and certifying generalization <em>post hoc</em> through empirical evaluations. When we get to :numref:<code>chap_perceptrons</code>, we will revisit generalization and provide a light introduction to the vast scientific literature that has sprung in attempts to explain why deep neural networks generalize in practice.</p><h2 id="The-Test-Set"><a class="docs-heading-anchor" href="#The-Test-Set">The Test Set</a><a id="The-Test-Set-1"></a><a class="docs-heading-anchor-permalink" href="#The-Test-Set" title="Permalink"></a></h2><p>Since we have already begun to rely on test sets as the gold standard method for assessing generalization error, let&#39;s get started by discussing the properties of such error estimates. Let&#39;s focus on a fixed classifier <span>$f$</span>, without worrying about how it was obtained. Moreover suppose that we possess a <em>fresh</em> dataset of examples <span>$\mathcal{D} = {(\mathbf{x}^{(i)},y^{(i)})}_{i=1}^n$</span> that were not used to train the classifier <span>$f$</span>. The <em>empirical error</em> of our classifier <span>$f$</span> on <span>$\mathcal{D}$</span> is simply the fraction of instances for which the prediction <span>$f(\mathbf{x}^{(i)})$</span> disagrees with the true label <span>$y^{(i)}$</span>, and is given by the following expression:</p><p class="math-container">\[\epsilon_\mathcal{D}(f) = \frac{1}{n}\sum_{i=1}^n \mathbf{1}(f(\mathbf{x}^{(i)}) \neq y^{(i)}).\]</p><p>By contrast, the <em>population error</em> is the <em>expected</em> fraction of examples in the underlying population (some distribution <span>$P(X,Y)$</span>  characterized by probability density function <span>$p(\mathbf{x},y)$</span>) for which our classifier disagrees with the true label:</p><p class="math-container">\[\epsilon(f) =  E_{(\mathbf{x}, y) \sim P} \mathbf{1}(f(\mathbf{x}) \neq y) =
\int\int \mathbf{1}(f(\mathbf{x}) \neq y) p(\mathbf{x}, y) \;d\mathbf{x} dy.\]</p><p>While <span>$\epsilon(f)$</span> is the quantity that we actually care about, we cannot observe it directly, just as we cannot directly observe the average height in a large population without measuring every single person. We can only estimate this quantity based on samples. Because our test set <span>$\mathcal{D}$</span> is statistically representative of the underlying population, we can view <span>$\epsilon_\mathcal{D}(f)$</span> as a statistical estimator of the population error <span>$\epsilon(f)$</span>. Moreover, because our quantity of interest <span>$\epsilon(f)$</span> is an expectation (of the random variable <span>$\mathbf{1}(f(X) \neq Y)$</span>) and the corresponding estimator <span>$\epsilon_\mathcal{D}(f)$</span> is the sample average, estimating the population error is simply the classic problem of mean estimation, which you may recall from :numref:<code>sec_prob</code>.</p><p>An important classical result from probability theory called the <em>central limit theorem</em> guarantees that whenever we possess <span>$n$</span> random samples <span>$a_1, ..., a_n$</span> drawn from any distribution with mean <span>$\mu$</span> and standard deviation <span>$\sigma$</span>, then, as the number of samples <span>$n$</span> approaches infinity, the sample average <span>$\hat{\mu}$</span> approximately tends towards a normal distribution centered at the true mean and with standard deviation <span>$\sigma/\sqrt{n}$</span>. Already, this tells us something important: as the number of examples grows large, our test error <span>$\epsilon_\mathcal{D}(f)$</span> should approach the true error <span>$\epsilon(f)$</span> at a rate of <span>$\mathcal{O}(1/\sqrt{n})$</span>. Thus, to estimate our test error twice as precisely, we must collect four times as large a test set. To reduce our test error by a factor of one hundred, we must collect ten thousand times as large a test set. In general, such a rate of <span>$\mathcal{O}(1/\sqrt{n})$</span> is often the best we can hope for in statistics.</p><p>Now that we know something about the asymptotic rate at which our test error <span>$\epsilon_\mathcal{D}(f)$</span> converges to the true error <span>$\epsilon(f)$</span>, we can zoom in on some important details. Recall that the random variable of interest <span>$\mathbf{1}(f(X) \neq Y)$</span> can only take values <span>$0$</span> and <span>$1$</span> and thus is a Bernoulli random variable, characterized by a parameter indicating the probability that it takes value <span>$1$</span>. Here, <span>$1$</span> means that our classifier made an error, so the parameter of our random variable is actually the true error rate <span>$\epsilon(f)$</span>. The variance <span>$\sigma^2$</span> of a Bernoulli depends on its parameter (here, <span>$\epsilon(f)$</span>) according to the expression <span>$\epsilon(f)(1-\epsilon(f))$</span>. While <span>$\epsilon(f)$</span> is initially unknown, we know that it cannot be greater than <span>$1$</span>. A little investigation of this function reveals that our variance is highest when the true error rate is close to <span>$0.5$</span> and can be far lower when it is close to <span>$0$</span> or close to <span>$1$</span>. This tells us that the asymptotic standard deviation of our estimate <span>$\epsilon_\mathcal{D}(f)$</span> of the error <span>$\epsilon(f)$</span> (over the choice of the <span>$n$</span> test samples) cannot be any greater than <span>$\sqrt{0.25/n}$</span>.</p><p>If we ignore the fact that this rate characterizes behavior as the test set size approaches infinity rather than when we possess finite samples, this tells us that if we want our test error <span>$\epsilon_\mathcal{D}(f)$</span> to approximate the population error <span>$\epsilon(f)$</span> such that one standard deviation corresponds to an interval of <span>$\pm 0.01$</span>, then we should collect roughly 2500 samples. If we want to fit two standard deviations in that range and thus be 95% confident that <span>$\epsilon_\mathcal{D}(f) \in \epsilon(f) \pm 0.01$</span>, then we will need 10,000 samples!</p><p>This turns out to be the size of the test sets for many popular benchmarks in machine learning. You might be surprised to find out that thousands of applied deep learning papers get published every year making a big deal out of error rate improvements of <span>$0.01$</span> or less. Of course, when the error rates are much closer to <span>$0$</span>, then an improvement of <span>$0.01$</span> can indeed be a big deal.</p><p>One pesky feature of our analysis thus far is that it really only tells us about asymptotics, i.e., how the relationship between <span>$\epsilon_\mathcal{D}$</span> and <span>$\epsilon$</span> evolves as our sample size goes to infinity. Fortunately, because our random variable is bounded, we can obtain valid finite sample bounds by applying an inequality due to Hoeffding (1963):</p><p class="math-container">\[P(\epsilon_\mathcal{D}(f) - \epsilon(f) \geq t) &lt; \exp\left( - 2n t^2 \right).\]</p><p>Solving for the smallest dataset size that would allow us to conclude with 95% confidence that the distance <span>$t$</span> between our estimate <span>$\epsilon_\mathcal{D}(f)$</span> and the true error rate <span>$\epsilon(f)$</span> does not exceed <span>$0.01$</span>, you will find that roughly 15,000 examples are required as compared to the 10,000 examples suggested by the asymptotic analysis above. If you go deeper into statistics you will find that this trend holds generally. Guarantees that hold even in finite samples are typically slightly more conservative. Note that in the scheme of things, these numbers are not so far apart, reflecting the general usefulness of asymptotic analysis for giving us ballpark figures even if they are not guarantees we can take to court.</p><h2 id="Test-Set-Reuse"><a class="docs-heading-anchor" href="#Test-Set-Reuse">Test Set Reuse</a><a id="Test-Set-Reuse-1"></a><a class="docs-heading-anchor-permalink" href="#Test-Set-Reuse" title="Permalink"></a></h2><p>In some sense, you are now set up to succeed at conducting empirical machine learning research. Nearly all practical models are developed and validated based on test set performance and you are now a master of the test set. For any fixed classifier <span>$f$</span>, you know how to evaluate its test error <span>$\epsilon_\mathcal{D}(f)$</span>, and know precisely what can (and cannot) be said about its population error <span>$\epsilon(f)$</span>.</p><p>So let&#39;s say that you take this knowledge and prepare to train your first model <span>$f_1$</span>. Knowing just how confident you need to be in the performance of your classifier&#39;s error rate you apply our analysis above to determine an appropriate number of examples to set aside for the test set. Moreover, let&#39;s assume that you took the lessons from :numref:<code>sec_generalization_basics</code> to heart and made sure to preserve the sanctity of the test set by conducting all of your preliminary analysis, hyperparameter tuning, and even selection among multiple competing model architectures on a validation set. Finally you evaluate your model <span>$f_1$</span> on the test set and report an unbiased estimate of the population error with an associated confidence interval.</p><p>So far everything seems to be going well. However, that night you wake up at 3am with a brilliant idea for a new modeling approach. The next day, you code up your new model, tune its hyperparameters on the validation set and not only are you getting your new model <span>$f_2$</span> to work but its error rate appears to be much lower than <span>$f_1$</span>&#39;s. However, the thrill of discovery suddenly fades as you prepare for the final evaluation. You do not have a test set!</p><p>Even though the original test set <span>$\mathcal{D}$</span> is still sitting on your server, you now face two formidable problems. First, when you collected your test set, you determined the required level of precision under the assumption that you were evaluating a single classifier <span>$f$</span>. However, if you get into the business of evaluating multiple classifiers <span>$f_1, ..., f_k$</span> on the same test set, you must consider the problem of false discovery. Before, you might have been 95% sure that <span>$\epsilon_\mathcal{D}(f) \in \epsilon(f) \pm 0.01$</span> for a single classifier <span>$f$</span> and thus the probability of a misleading result was a mere 5%. With <span>$k$</span> classifiers in the mix, it can be hard to guarantee that there is not even one among them whose test set performance is misleading. With 20 classifiers under consideration, you might have no power at all to rule out the possibility that at least one among them received a misleading score. This problem relates to multiple hypothesis testing, which despite a vast literature in statistics, remains a persistent problem plaguing scientific research.</p><p>If that is not enough to worry you, there is a special reason to distrust the results that you get on subsequent evaluations. Recall that our analysis of test set performance rested on the assumption that the classifier was chosen absent any contact with the test set and thus we could view the test set as drawn randomly from the underlying population. Here, not only are you testing multiple functions, the subsequent function <span>$f_2$</span> was chosen after you observed the test set performance of <span>$f_1$</span>. Once information from the test set has leaked to the modeler, it can never be a true test set again in the strictest sense. This problem is called <em>adaptive overfitting</em> and has recently emerged as a topic of intense interest to learning theorists and statisticians :cite:<code>dwork2015preserving</code>. Fortunately, while it is possible to leak all information out of a holdout set, and the theoretical worst case scenarios are bleak, these analyses may be too conservative. In practice, take care to create real test sets, to consult them as infrequently as possible, to account for multiple hypothesis testing when reporting confidence intervals, and to dial up your vigilance more aggressively when the stakes are high and your dataset size is small. When running a series of benchmark challenges, it is often good practice to maintain several test sets so that after each round, the old test set can be demoted to a validation set.</p><h2 id="Statistical-Learning-Theory"><a class="docs-heading-anchor" href="#Statistical-Learning-Theory">Statistical Learning Theory</a><a id="Statistical-Learning-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Statistical-Learning-Theory" title="Permalink"></a></h2><p>Put simply, <em>test sets are all that we really have</em>, and yet this fact seems strangely unsatisfying. First, we seldom possess a <em>true test set</em>–-unless we are the ones creating the dataset, someone else has probably already evaluated their own classifier on our ostensible &quot;test set&quot;. And even when we have first dibs, we soon find ourselves frustrated, wishing we could evaluate our subsequent modeling attempts without the gnawing feeling that we cannot trust our numbers. Moreover, even a true test set can only tell us <em>post hoc</em> whether a classifier has in fact generalized to the population, not whether we have any reason to expect <em>a priori</em> that it should generalize.</p><p>With these misgivings in mind, you might now be sufficiently primed to see the appeal of <em>statistical learning theory</em>, the mathematical subfield of machine learning whose practitioners aim to elucidate the fundamental principles that explain why/when models trained on empirical data can/will generalize to unseen data. One of the primary aims of statistical learning researchers has been to bound the generalization gap, relating the properties of the model class to the number of samples in the dataset.</p><p>Learning theorists aim to bound the difference between the <em>empirical error</em> <span>$\epsilon_\mathcal{S}(f_\mathcal{S})$</span> of a learned classifier <span>$f_\mathcal{S}$</span>, both trained and evaluated on the training set <span>$\mathcal{S}$</span>, and the true error <span>$\epsilon(f_\mathcal{S})$</span> of that same classifier on the underlying population. This might look similar to the evaluation problem that we just addressed but there is a major difference. Earlier, the classifier <span>$f$</span> was fixed and we only needed a dataset for evaluative purposes. And indeed, any fixed classifier does generalize: its error on a (previously unseen) dataset is an unbiased estimate of the population error. But what can we say when a classifier is trained and evaluated on the same dataset? Can we ever be confident that the training error will be close to the testing error?</p><p>Suppose that our learned classifier <span>$f_\mathcal{S}$</span> must be chosen from some pre-specified set of functions <span>$\mathcal{F}$</span>. Recall from our discussion of test sets that while it is easy to estimate the error of a single classifier, things get hairy when we begin to consider collections of classifiers. Even if the empirical error of any one (fixed) classifier will be close to its true error with high probability, once we consider a collection of classifiers, we need to worry about the possibility that <em>just one</em> of them will receive a badly estimated error. The worry is that we might pick such a classifier and thereby grossly underestimate the population error. Moreover, even for linear models, because their parameters are continuously valued, we are typically choosing from an infinite class of functions (<span>$|\mathcal{F}| = \infty$</span>).</p><p>One ambitious solution to the problem is to develop analytic tools for proving uniform convergence, i.e., that with high probability, the empirical error rate for every classifier in the class <span>$f\in\mathcal{F}$</span> will <em>simultaneously</em> converge to its true error rate. In other words, we seek a theoretical principle that would allow us to state that with probability at least <span>$1-\delta$</span> (for some small <span>$\delta$</span>) no classifier&#39;s error rate <span>$\epsilon(f)$</span> (among all classifiers in the class <span>$\mathcal{F}$</span>) will be misestimated by more than some  small amount <span>$\alpha$</span>. Clearly, we cannot make such statements for all model classes <span>$\mathcal{F}$</span>. Recall the class of memorization machines that always achieve empirical error <span>$0$</span> but never outperform random guessing on the underlying population.</p><p>In a sense the class of memorizers is too flexible. No such a uniform convergence result could possibly hold. On the other hand, a fixed classifier is useless–-it generalizes perfectly, but fits neither the training data nor the test data. The central question of learning has thus historically been framed as a trade-off between more flexible (higher variance) model classes that better fit the training data but risk overfitting, versus more rigid (higher bias) model classes that generalize well but risk underfitting. A central question in learning theory has been to develop the appropriate mathematical analysis to quantify where a model sits along this spectrum, and to provide the associated guarantees.</p><p>In a series of seminal papers, Vapnik and Chervonenkis extended the theory on the convergence of relative frequencies to more general classes of functions :cite:<code>VapChe64,VapChe68,VapChe71,VapChe74b,VapChe81,VapChe91</code>. One of the key contributions of this line of work is the Vapnik–Chervonenkis (VC) dimension, which measures (one notion of) the complexity (flexibility) of a model class. Moreover, one of their key results bounds the difference between the empirical error and the population error as a function of the VC dimension and the number of samples:</p><p class="math-container">\[P\left(R[p, f] - R_\textrm{emp}[\mathbf{X}, \mathbf{Y}, f] &lt; \alpha\right) \geq 1-\delta
\ \textrm{ for }\ \alpha \geq c \sqrt{(\textrm{VC} - \log \delta)/n}.\]</p><p>Here <span>$\delta &gt; 0$</span> is the probability that the bound is violated, <span>$\alpha$</span> is the upper bound on the generalization gap, and <span>$n$</span> is the dataset size. Lastly, <span>$c &gt; 0$</span> is a constant that depends only on the scale of the loss that can be incurred. One use of the bound might be to plug in desired values of <span>$\delta$</span> and <span>$\alpha$</span> to determine how many samples to collect. The VC dimension quantifies the largest number of data points for which we can assign any arbitrary (binary) labeling and for each find some model <span>$f$</span> in the class that agrees with that labeling. For example, linear models on <span>$d$</span>-dimensional inputs have VC dimension <span>$d+1$</span>. It is easy to see that a line can assign any possible labeling to three points in two dimensions, but not to four. Unfortunately, the theory tends to be overly pessimistic for more complex models and obtaining this guarantee typically requires far more examples than are actually needed to achieve the desired error rate. Note also that fixing the model class and <span>$\delta$</span>, our error rate again decays with the usual <span>$\mathcal{O}(1/\sqrt{n})$</span> rate. It seems unlikely that we could do better in terms of <span>$n$</span>. However, as we vary the model class, VC dimension can present a pessimistic picture of the generalization gap.</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>The most straightforward way to evaluate a model is to consult a test set comprised of previously unseen data. Test set evaluations provide an unbiased estimate of the true error and converge at the desired <span>$\mathcal{O}(1/\sqrt{n})$</span> rate as the test set grows. We can provide approximate confidence intervals based on exact asymptotic distributions or valid finite sample confidence intervals based on (more conservative) finite sample guarantees. Indeed test set evaluation is the bedrock of modern machine learning research. However, test sets are seldom true test sets (used by multiple researchers again and again). Once the same test set is used to evaluate multiple models, controlling for false discovery can be difficult. This can cause huge problems in theory. In practice, the significance of the problem depends on the size of the holdout sets in question and whether they are merely being used to choose hyperparameters or if they are leaking information more directly. Nevertheless, it is good practice to curate real test sets (or multiple) and to be as conservative as possible about how often they are used.</p><p>Hoping to provide a more satisfying solution, statistical learning theorists have developed methods for guaranteeing uniform convergence over a model class. If indeed every model&#39;s empirical error simultaneously converges to its true error, then we are free to choose the model that performs best, minimizing the training error, knowing that it too will perform similarly well on the holdout data. Crucially, any one of such results must depend on some property of the model class. Vladimir Vapnik and Alexey Chernovenkis introduced the VC dimension, presenting uniform convergence results that hold for all models in a VC class. The training errors for all models in the class are (simultaneously) guaranteed to be close to their true errors, and guaranteed to grow even closer at <span>$\mathcal{O}(1/\sqrt{n})$</span> rates. Following the revolutionary discovery of VC dimension, numerous alternative complexity measures have been proposed, each facilitating an analogous generalization guarantee. See :citet:<code>boucheron2005theory</code> for a detailed discussion of several advanced ways of measuring function complexity. Unfortunately, while these complexity measures have become broadly useful tools in statistical theory, they turn out to be powerless (as straightforwardly applied) for explaining why deep neural networks generalize. Deep neural networks often have millions of parameters (or more), and can easily assign random labels to large collections of points. Nevertheless, they generalize well on practical problems and, surprisingly, they often generalize better, when they are larger and deeper, despite incurring higher VC dimensions. In the next chapter, we will revisit generalization in the context of deep learning.</p><h2 id="Exercises"><a class="docs-heading-anchor" href="#Exercises">Exercises</a><a id="Exercises-1"></a><a class="docs-heading-anchor-permalink" href="#Exercises" title="Permalink"></a></h2><ol><li>If we wish to estimate the error of a fixed model <span>$f$</span> to within <span>$0.0001$</span> with probability greater than 99.9%, how many samples do we need?</li><li>Suppose that somebody else possesses a labeled test set <span>$\mathcal{D}$</span> and only makes available the unlabeled inputs (features). Now suppose that you can only access the test set labels by running a model <span>$f$</span> (with no restrictions placed on the model class) on each of the unlabeled inputs and receiving the corresponding error <span>$\epsilon_\mathcal{D}(f)$</span>. How many models would you need to evaluate before you leak the entire test set and thus could appear to have error <span>$0$</span>, regardless of your true error?</li><li>What is the VC dimension of the class of fifth-order polynomials?</li><li>What is the VC dimension of axis-aligned rectangles on two-dimensional data?</li></ol><p><a href="https://discuss.d2l.ai/t/6829">Discussions</a></p><pre><code class="language-julia hljs"></code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../LCN_4/">« Concise Implementation of Softmax Regression</a><a class="docs-footer-nextpage" href="../LCN_6/">Environment and Distribution Shift »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Sunday 15 June 2025 19:32">Sunday 15 June 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
