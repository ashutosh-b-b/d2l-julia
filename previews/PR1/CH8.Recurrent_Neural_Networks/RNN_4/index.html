<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Recurrent Neural Networks · d2l Julia</title><meta name="title" content="Recurrent Neural Networks · d2l Julia"/><meta property="og:title" content="Recurrent Neural Networks · d2l Julia"/><meta property="twitter:title" content="Recurrent Neural Networks · d2l Julia"/><meta name="description" content="Documentation for d2l Julia."/><meta property="og:description" content="Documentation for d2l Julia."/><meta property="twitter:description" content="Documentation for d2l Julia."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../CH3.Linear_Regression/LNN_1/">d2l Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Linear Neural Networks for Regression</span><ul><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_1/">Linear Regression</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_2/">Multiple Dispatch Design for Implementation</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_3/">Synthetic Regression Data</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_4/">Linear Regression Implementation from Scratch</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_5/">Concise Implementation of Linear Regression</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_6/">Generalization</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_7/">Weight Decay</a></li></ul></li><li><span class="tocitem">Linear Neural Networks for Classification</span><ul><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_1/">Softmax Regression</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_2/">The Image Classification Dataset</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_3/">Softmax Regression Implementation from Scratch</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_4/">Concise Implementation of Softmax Regression</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_5/">Generalization in Classification</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_6/">Environment and Distribution Shift</a></li></ul></li><li><span class="tocitem">Multilayer Perceptron</span><ul><li><a class="tocitem" href="../../CH5.MLP/MLP_1/">Multilayer Perceptrons</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_2/">Implementation of Multilayer Perceptrons</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_3/">Forward Propagation, Backward Propagation, and Computational Graphs</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_4/">Numerical Stability and Initialization</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_5/">Generalization in Deep Learning</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_6/">Dropout</a></li></ul></li><li><span class="tocitem">Convolutional Neural Networks</span><ul><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_2/">Convolutions for Images</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_3/">Padding and Stride</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_4/">Multiple Input and Multiple Output Channels</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_5/">Pooling</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_6/">Convolutional Neural Networks (LeNet)</a></li></ul></li><li><span class="tocitem">Modern Convolutional Neural Networks</span><ul><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_0/">Modern Convolutional Neural Networks</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_1/">Deep Convolutional Neural Networks (AlexNet)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_2/">Networks Using Blocks (VGG)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_3/">-</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_4/">Multi-Branch Networks  (GoogLeNet)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_5/">-</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_6/">Residual Networks (ResNet) and ResNeXt</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_7/">Densely Connected Networks (DenseNet)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_8/">Designing Convolution Network Architectures</a></li></ul></li><li><span class="tocitem">Recurrent Neural Networks</span><ul><li><a class="tocitem" href="../RNN_0/">Recurrent Neural Networks</a></li><li><a class="tocitem" href="../RNN_1/">Working with Sequences</a></li><li><a class="tocitem" href="../RNN_2/">Converting Raw Text into Sequence Data</a></li><li><a class="tocitem" href="../RNN_3/">Language Models</a></li><li class="is-active"><a class="tocitem" href>Recurrent Neural Networks</a><ul class="internal"><li><a class="tocitem" href="#Neural-Networks-without-Hidden-States"><span>Neural Networks without Hidden States</span></a></li><li><a class="tocitem" href="#Recurrent-Neural-Networks-with-Hidden-States"><span>Recurrent Neural Networks with Hidden States</span></a></li><li><a class="tocitem" href="#RNN-Based-Character-Level-Language-Models"><span>RNN-Based Character-Level Language Models</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li><li><a class="tocitem" href="#Exercises"><span>Exercises</span></a></li></ul></li><li><a class="tocitem" href="../RNN_5/">Recurrent Neural Network Implementation from Scratch</a></li><li><a class="tocitem" href="../RNN_6/">Concise Implementation of Recurrent Neural Networks</a></li><li><a class="tocitem" href="../RNN_7/">Backpropagation Through Time</a></li></ul></li><li><span class="tocitem">Modern Recurrent Neural Networks</span><ul><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN7/">Sequence-to-Sequence Learning for Machine Translation</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_1/">Long Short-Term Memory (LSTM)</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_2/">Gated Recurrent Units (GRU)</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_3/">-</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_4/">Bidirectional Recurrent Neural Networks</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_5/">Machine Translation and the Dataset</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_6/">The Encoder–Decoder Architecture</a></li></ul></li><li><span class="tocitem">Attention Mechanisms and Transformers</span><ul><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_1/">Queries, Keys, and Values</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_2/">Attention Pooling by Similarity</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_3/">Attention Scoring Functions</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_4/">The Bahdanau Attention Mechanism</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_5/">Multi-Head Attention</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_6/">Self-Attention and Positional Encoding</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/Untitled/">-</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Recurrent Neural Networks</a></li><li class="is-active"><a href>Recurrent Neural Networks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Recurrent Neural Networks</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Recurrent-Neural-Networks"><a class="docs-heading-anchor" href="#Recurrent-Neural-Networks">Recurrent Neural Networks</a><a id="Recurrent-Neural-Networks-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrent-Neural-Networks" title="Permalink"></a></h1><p>:label:<code>sec_rnn</code></p><p>In :numref:<code>sec_language-model</code> we described Markov models and <span>$n$</span>-grams for language modeling, where the conditional probability of token <span>$x_t$</span> at time step <span>$t$</span> only depends on the <span>$n-1$</span> previous tokens. If we want to incorporate the possible effect of tokens earlier than time step <span>$t-(n-1)$</span> on <span>$x_t$</span>, we need to increase <span>$n$</span>. However, the number of model parameters would also increase exponentially with it, as we need to store <span>$|\mathcal{V}|^n$</span> numbers for a vocabulary set <span>$\mathcal{V}$</span>. Hence, rather than modeling <span>$P(x_t \mid x_{t-1}, \ldots, x_{t-n+1})$</span> it is preferable to use a latent variable model,</p><p>$</p><p>P(x<em>t \mid x</em>{t-1}, \ldots, x<em>1) \approx P(x</em>t \mid h_{t-1}) $</p><p>where <span>$h_{t-1}$</span> is a <em>hidden state</em>  that stores the sequence information up to time step <span>$t-1$</span>. In general, the hidden state at any time step <span>$t$</span> could be computed based on both the current input <span>$x_{t}$</span> and the previous hidden state <span>$h_{t-1}$</span>:</p><p class="math-container">\[h_t = f(x_{t}, h_{t-1}).\]</p><p>:eqlabel:<code>eq_ht_xt</code></p><p>For a sufficiently powerful function <span>$f$</span> in :eqref:<code>eq_ht_xt</code>, the latent variable model is not an approximation. After all, <span>$h_t$</span> may simply store all the data it has observed so far. However, it could potentially make both computation and storage expensive.</p><p>Recall that we have discussed hidden layers with hidden units in :numref:<code>chap_perceptrons</code>. It is noteworthy that hidden layers and hidden states refer to two very different concepts. Hidden layers are, as explained, layers that are hidden from view on the path from input to output. Hidden states are technically speaking <em>inputs</em> to whatever we do at a given step, and they can only be computed by looking at data at previous time steps.</p><p><em>Recurrent neural networks</em> (RNNs) are neural networks with hidden states. Before introducing the RNN model, we first revisit the MLP model introduced in :numref:<code>sec_mlp</code>.</p><pre><code class="language-julia hljs">using Pkg; Pkg.activate(&quot;../../d2lai&quot;)
using d2lai
using Flux 
using Downloads
using StatsBase
using Plots
</code></pre><pre><code class="nohighlight hljs">  Activating project at `/workspace/d2l-julia/d2lai`</code></pre><h2 id="Neural-Networks-without-Hidden-States"><a class="docs-heading-anchor" href="#Neural-Networks-without-Hidden-States">Neural Networks without Hidden States</a><a id="Neural-Networks-without-Hidden-States-1"></a><a class="docs-heading-anchor-permalink" href="#Neural-Networks-without-Hidden-States" title="Permalink"></a></h2><p>Let&#39;s take a look at an MLP with a single hidden layer. Let the hidden layer&#39;s activation function be <span>$\phi$</span>. Given a minibatch of examples <span>$\mathbf{X} \in \mathbb{R}^{n \times d}$</span> with batch size <span>$n$</span> and <span>$d$</span> inputs, the hidden layer output <span>$\mathbf{H} \in \mathbb{R}^{n \times h}$</span> is calculated as</p><p class="math-container">\[\mathbf{H} = \phi(\mathbf{X} \mathbf{W}_{\textrm{xh}} + \mathbf{b}_\textrm{h}).\]</p><p>:eqlabel:<code>rnn_h_without_state</code></p><p>In :eqref:<code>rnn_h_without_state</code>, we have the weight parameter <span>$\mathbf{W}_{\textrm{xh}} \in \mathbb{R}^{d \times h}$</span>, the bias parameter <span>$\mathbf{b}_\textrm{h} \in \mathbb{R}^{1 \times h}$</span>, and the number of hidden units <span>$h$</span>, for the hidden layer. So armed, we apply broadcasting (see :numref:<code>subsec_broadcasting</code>) during the summation. Next, the hidden layer output <span>$\mathbf{H}$</span> is used as input of the output layer, which is given by</p><p class="math-container">\[\mathbf{O} = \mathbf{H} \mathbf{W}_{\textrm{hq}} + \mathbf{b}_\textrm{q},\]</p><p>where <span>$\mathbf{O} \in \mathbb{R}^{n \times q}$</span> is the output variable, <span>$\mathbf{W}_{\textrm{hq}} \in \mathbb{R}^{h \times q}$</span> is the weight parameter, and <span>$\mathbf{b}_\textrm{q} \in \mathbb{R}^{1 \times q}$</span> is the bias parameter of the output layer.  If it is a classification problem, we can use <span>$\mathrm{softmax}(\mathbf{O})$</span> to compute the probability distribution of the output categories.</p><p>This is entirely analogous to the regression problem we solved previously in :numref:<code>sec_sequence</code>, hence we omit details. Suffice it to say that we can pick feature-label pairs at random and learn the parameters of our network via automatic differentiation and stochastic gradient descent.</p><h2 id="Recurrent-Neural-Networks-with-Hidden-States"><a class="docs-heading-anchor" href="#Recurrent-Neural-Networks-with-Hidden-States">Recurrent Neural Networks with Hidden States</a><a id="Recurrent-Neural-Networks-with-Hidden-States-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrent-Neural-Networks-with-Hidden-States" title="Permalink"></a></h2><p>:label:<code>subsec_rnn_w_hidden_states</code></p><p>Matters are entirely different when we have hidden states. Let&#39;s look at the structure in some more detail.</p><p>Assume that we have a minibatch of inputs <span>$\mathbf{X}_t \in \mathbb{R}^{n \times d}$</span> at time step <span>$t$</span>. In other words, for a minibatch of <span>$n$</span> sequence examples, each row of <span>$\mathbf{X}_t$</span> corresponds to one example at time step <span>$t$</span> from the sequence. Next, denote by <span>$\mathbf{H}_t  \in \mathbb{R}^{n \times h}$</span> the hidden layer output of time step <span>$t$</span>. Unlike with MLP, here we save the hidden layer output <span>$\mathbf{H}_{t-1}$</span> from the previous time step and introduce a new weight parameter <span>$\mathbf{W}_{\textrm{hh}} \in \mathbb{R}^{h \times h}$</span> to describe how to use the hidden layer output of the previous time step in the current time step. Specifically, the calculation of the hidden layer output of the current time step is determined by the input of the current time step together with the hidden layer output of the previous time step:</p><p class="math-container">\[\mathbf{H}_t = \phi(\mathbf{X}_t \mathbf{W}_{\textrm{xh}} + \mathbf{H}_{t-1} \mathbf{W}_{\textrm{hh}}  + \mathbf{b}_\textrm{h}).\]</p><p>:eqlabel:<code>rnn_h_with_state</code></p><p>Compared with :eqref:<code>rnn_h_without_state</code>, :eqref:<code>rnn_h_with_state</code> adds one more term <span>$\mathbf{H}_{t-1} \mathbf{W}_{\textrm{hh}}$</span> and thus instantiates :eqref:<code>eq_ht_xt</code>. From the relationship between hidden layer outputs <span>$\mathbf{H}_t$</span> and <span>$\mathbf{H}_{t-1}$</span> of adjacent time steps, we know that these variables captured and retained the sequence&#39;s historical information up to their current time step, just like the state or memory of the neural network&#39;s current time step. Therefore, such a hidden layer output is called a <em>hidden state</em>. Since the hidden state uses the same definition of the previous time step in the current time step, the computation of :eqref:<code>rnn_h_with_state</code> is <em>recurrent</em>. Hence, as we said, neural networks with hidden states based on recurrent computation are named <em>recurrent neural networks</em>. Layers that perform the computation of :eqref:<code>rnn_h_with_state</code> in RNNs are called <em>recurrent layers</em>.</p><p>There are many different ways for constructing RNNs. Those with a hidden state defined by :eqref:<code>rnn_h_with_state</code> are very common. For time step <span>$t$</span>, the output of the output layer is similar to the computation in the MLP:</p><p class="math-container">\[\mathbf{O}_t = \mathbf{H}_t \mathbf{W}_{\textrm{hq}} + \mathbf{b}_\textrm{q}.\]</p><p>Parameters of the RNN include the weights <span>$\mathbf{W}_{\textrm{xh}} \in \mathbb{R}^{d \times h}, \mathbf{W}_{\textrm{hh}} \in \mathbb{R}^{h \times h}$</span>, and the bias <span>$\mathbf{b}_\textrm{h} \in \mathbb{R}^{1 \times h}$</span> of the hidden layer, together with the weights <span>$\mathbf{W}_{\textrm{hq}} \in \mathbb{R}^{h \times q}$</span> and the bias <span>$\mathbf{b}_\textrm{q} \in \mathbb{R}^{1 \times q}$</span> of the output layer. It is worth mentioning that even at different time steps, RNNs always use these model parameters. Therefore, the parametrization cost of an RNN does not grow as the number of time steps increases.</p><p>:numref:<code>fig_rnn</code> illustrates the computational logic of an RNN at three adjacent time steps. At any time step <span>$t$</span>, the computation of the hidden state can be treated as: (i) concatenating the input <span>$\mathbf{X}_t$</span> at the current time step <span>$t$</span> and the hidden state <span>$\mathbf{H}_{t-1}$</span> at the previous time step <span>$t-1$</span>; (ii) feeding the concatenation result into a fully connected layer with the activation function <span>$\phi$</span>. The output of such a fully connected layer is the hidden state <span>$\mathbf{H}_t$</span> of the current time step <span>$t$</span>. In this case, the model parameters are the concatenation of <span>$\mathbf{W}_{\textrm{xh}}$</span> and <span>$\mathbf{W}_{\textrm{hh}}$</span>, and a bias of <span>$\mathbf{b}_\textrm{h}$</span>, all from :eqref:<code>rnn_h_with_state</code>. The hidden state of the current time step <span>$t$</span>, <span>$\mathbf{H}_t$</span>, will participate in computing the hidden state <span>$\mathbf{H}_{t+1}$</span> of the next time step <span>$t+1$</span>. What is more, <span>$\mathbf{H}_t$</span> will also be fed into the fully connected output layer to compute the output <span>$\mathbf{O}_t$</span> of the current time step <span>$t$</span>.</p><p><img src="../../img/rnn.svg" alt="An RNN with a hidden state."/> :label:<code>fig_rnn</code></p><p>We just mentioned that the calculation of <span>$\mathbf{X}_t \mathbf{W}_{\textrm{xh}} + \mathbf{H}_{t-1} \mathbf{W}_{\textrm{hh}}$</span> for the hidden state is equivalent to matrix multiplication of the concatenation of <span>$\mathbf{X}_t$</span> and <span>$\mathbf{H}_{t-1}$</span> and the concatenation of <span>$\mathbf{W}_{\textrm{xh}}$</span> and <span>$\mathbf{W}_{\textrm{hh}}$</span>. Though this can be proven mathematically, in the following we just use a simple code snippet as a demonstration. To begin with, we define matrices <code>X</code>, <code>W_xh</code>, <code>H</code>, and <code>W_hh</code>, whose shapes are (3, 1), (1, 4), (3, 4), and (4, 4), respectively. Multiplying <code>X</code> by <code>W_xh</code>, and <code>H</code> by <code>W_hh</code>, and then adding these two products, we obtain a matrix of shape (3, 4).</p><pre><code class="language-julia hljs">X, Wxh = rand(1, 3), rand(4, 1)
H, Whh = rand(4, 3), rand(4,4)
Wxh*X + Whh*H</code></pre><pre><code class="nohighlight hljs">4×3 Matrix{Float64}:
 1.05201  1.00062  1.67581
 1.60482  1.98626  2.43147
 0.93348  1.02113  1.48314
 1.47263  1.4634   2.25598</code></pre><p>Now we concatenate the matrices <code>X</code> and <code>H</code> along columns (axis 1), and the matrices <code>W_xh</code> and <code>W_hh</code> along rows (axis 0). These two concatenations result in matrices of shape (3, 5) and of shape (5, 4), respectively. Multiplying these two concatenated matrices, we obtain the same output matrix of shape (3, 4) as above.</p><pre><code class="language-julia hljs">hcat(Wxh, Whh)*vcat(X, H)</code></pre><pre><code class="nohighlight hljs">4×3 Matrix{Float64}:
 1.05201  1.00062  1.67581
 1.60482  1.98626  2.43147
 0.93348  1.02113  1.48314
 1.47263  1.4634   2.25598</code></pre><h2 id="RNN-Based-Character-Level-Language-Models"><a class="docs-heading-anchor" href="#RNN-Based-Character-Level-Language-Models">RNN-Based Character-Level Language Models</a><a id="RNN-Based-Character-Level-Language-Models-1"></a><a class="docs-heading-anchor-permalink" href="#RNN-Based-Character-Level-Language-Models" title="Permalink"></a></h2><p>Recall that for language modeling in :numref:<code>sec_language-model</code>, we aim to predict the next token based on the current and past tokens; thus we shift the original sequence by one token as the targets (labels). :citet:<code>Bengio.Ducharme.Vincent.ea.2003</code> first proposed to use a neural network for language modeling. In the following we illustrate how RNNs can be used to build a language model. Let the minibatch size be one, and the sequence of the text be &quot;machine&quot;. To simplify training in subsequent sections, we tokenize text into characters rather than words and consider a <em>character-level language model</em>. :numref:<code>fig_rnn_train</code> demonstrates how to predict the next character based on the current and previous characters via an RNN for character-level language modeling.</p><p><img src="../../img/rnn-train.svg" alt="A character-level language model based on the RNN. The input and target sequences are &quot;machin&quot; and &quot;achine&quot;, respectively."/> :label:<code>fig_rnn_train</code></p><p>During the training process, we run a softmax operation on the output from the output layer for each time step, and then use the cross-entropy loss to compute the error between the model output and the target. Because of the recurrent computation of the hidden state in the hidden layer, the output, <span>$\mathbf{O}_3$</span>,  of time step 3 in :numref:<code>fig_rnn_train</code> is determined by the text sequence &quot;m&quot;, &quot;a&quot;, and &quot;c&quot;. Since the next character of the sequence in the training data is &quot;h&quot;, the loss of time step 3 will depend on the probability distribution of the next character generated based on the feature sequence &quot;m&quot;, &quot;a&quot;, &quot;c&quot; and the target &quot;h&quot; of this time step.</p><p>In practice, each token is represented by a <span>$d$</span>-dimensional vector, and we use a batch size <span>$n&gt;1$</span>. Therefore, the input <span>$\mathbf X_t$</span> at time step <span>$t$</span> will be an <span>$n\times d$</span> matrix, which is identical to what we discussed in :numref:<code>subsec_rnn_w_hidden_states</code>.</p><p>In the following sections, we will implement RNNs for character-level language models.</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>A neural network that uses recurrent computation for hidden states is called a recurrent neural network (RNN). The hidden state of an RNN can capture historical information of the sequence up to the current time step. With recurrent computation, the number of RNN model parameters does not grow as the number of time steps increases. As for applications, an RNN can be used to create character-level language models.</p><h2 id="Exercises"><a class="docs-heading-anchor" href="#Exercises">Exercises</a><a id="Exercises-1"></a><a class="docs-heading-anchor-permalink" href="#Exercises" title="Permalink"></a></h2><ol><li>If we use an RNN to predict the next character in a text sequence, what is the required dimension for any output?</li><li>Why can RNNs express the conditional probability of a token at some time step based on all the previous tokens in the text sequence?</li><li>What happens to the gradient if you backpropagate through a long sequence?</li><li>What are some of the problems associated with the language model described in this section?</li></ol><pre><code class="language-julia hljs"></code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../RNN_3/">« Language Models</a><a class="docs-footer-nextpage" href="../RNN_5/">Recurrent Neural Network Implementation from Scratch »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Sunday 15 June 2025 19:32">Sunday 15 June 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
