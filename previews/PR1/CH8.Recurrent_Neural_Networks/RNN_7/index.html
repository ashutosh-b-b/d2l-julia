<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Backpropagation Through Time · d2l Julia</title><meta name="title" content="Backpropagation Through Time · d2l Julia"/><meta property="og:title" content="Backpropagation Through Time · d2l Julia"/><meta property="twitter:title" content="Backpropagation Through Time · d2l Julia"/><meta name="description" content="Documentation for d2l Julia."/><meta property="og:description" content="Documentation for d2l Julia."/><meta property="twitter:description" content="Documentation for d2l Julia."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../CH3.Linear_Regression/LNN_1/">d2l Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Linear Neural Networks for Regression</span><ul><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_1/">Linear Regression</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_2/">Multiple Dispatch Design for Implementation</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_3/">Synthetic Regression Data</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_4/">Linear Regression Implementation from Scratch</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_5/">Concise Implementation of Linear Regression</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_6/">Generalization</a></li><li><a class="tocitem" href="../../CH3.Linear_Regression/LNN_7/">Weight Decay</a></li></ul></li><li><span class="tocitem">Linear Neural Networks for Classification</span><ul><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_1/">Softmax Regression</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_2/">The Image Classification Dataset</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_3/">Softmax Regression Implementation from Scratch</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_4/">Concise Implementation of Softmax Regression</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_5/">Generalization in Classification</a></li><li><a class="tocitem" href="../../CH4.Linear_Classification/LCN_6/">Environment and Distribution Shift</a></li></ul></li><li><span class="tocitem">Multilayer Perceptron</span><ul><li><a class="tocitem" href="../../CH5.MLP/MLP_1/">Multilayer Perceptrons</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_2/">Implementation of Multilayer Perceptrons</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_3/">Forward Propagation, Backward Propagation, and Computational Graphs</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_4/">Numerical Stability and Initialization</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_5/">Generalization in Deep Learning</a></li><li><a class="tocitem" href="../../CH5.MLP/MLP_6/">Dropout</a></li></ul></li><li><span class="tocitem">Convolutional Neural Networks</span><ul><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_2/">Convolutions for Images</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_3/">Padding and Stride</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_4/">Multiple Input and Multiple Output Channels</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_5/">Pooling</a></li><li><a class="tocitem" href="../../CH6.Convolutional_Neural_Networks/CNN_6/">Convolutional Neural Networks (LeNet)</a></li></ul></li><li><span class="tocitem">Modern Convolutional Neural Networks</span><ul><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_0/">Modern Convolutional Neural Networks</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_1/">Deep Convolutional Neural Networks (AlexNet)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_2/">Networks Using Blocks (VGG)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_3/">-</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_4/">Multi-Branch Networks  (GoogLeNet)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_5/">-</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_6/">Residual Networks (ResNet) and ResNeXt</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_7/">Densely Connected Networks (DenseNet)</a></li><li><a class="tocitem" href="../../CH7.ModernConvolutionalNeuralNetworks/MCNN_8/">Designing Convolution Network Architectures</a></li></ul></li><li><span class="tocitem">Recurrent Neural Networks</span><ul><li><a class="tocitem" href="../RNN_0/">Recurrent Neural Networks</a></li><li><a class="tocitem" href="../RNN_1/">Working with Sequences</a></li><li><a class="tocitem" href="../RNN_2/">Converting Raw Text into Sequence Data</a></li><li><a class="tocitem" href="../RNN_3/">Language Models</a></li><li><a class="tocitem" href="../RNN_4/">Recurrent Neural Networks</a></li><li><a class="tocitem" href="../RNN_5/">Recurrent Neural Network Implementation from Scratch</a></li><li><a class="tocitem" href="../RNN_6/">Concise Implementation of Recurrent Neural Networks</a></li><li class="is-active"><a class="tocitem" href>Backpropagation Through Time</a><ul class="internal"><li><a class="tocitem" href="#Analysis-of-Gradients-in-RNNs"><span>Analysis of Gradients in RNNs</span></a></li><li><a class="tocitem" href="#Backpropagation-Through-Time-in-Detail"><span>Backpropagation Through Time in Detail</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li><li><a class="tocitem" href="#Exercises"><span>Exercises</span></a></li></ul></li></ul></li><li><span class="tocitem">Modern Recurrent Neural Networks</span><ul><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN7/">Sequence-to-Sequence Learning for Machine Translation</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_1/">Long Short-Term Memory (LSTM)</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_2/">Gated Recurrent Units (GRU)</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_3/">-</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_4/">Bidirectional Recurrent Neural Networks</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_5/">Machine Translation and the Dataset</a></li><li><a class="tocitem" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN_6/">The Encoder–Decoder Architecture</a></li></ul></li><li><span class="tocitem">Attention Mechanisms and Transformers</span><ul><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_1/">Queries, Keys, and Values</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_2/">Attention Pooling by Similarity</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_3/">Attention Scoring Functions</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_4/">The Bahdanau Attention Mechanism</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_5/">Multi-Head Attention</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/ATTN_6/">Self-Attention and Positional Encoding</a></li><li><a class="tocitem" href="../../CH10.Attention_Mechanisms_and_Transformers/Untitled/">-</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Recurrent Neural Networks</a></li><li class="is-active"><a href>Backpropagation Through Time</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Backpropagation Through Time</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Backpropagation-Through-Time"><a class="docs-heading-anchor" href="#Backpropagation-Through-Time">Backpropagation Through Time</a><a id="Backpropagation-Through-Time-1"></a><a class="docs-heading-anchor-permalink" href="#Backpropagation-Through-Time" title="Permalink"></a></h1><p>:label:<code>sec_bptt</code></p><p>If you completed the exercises in :numref:<code>sec_rnn-scratch</code>, you would have seen that gradient clipping is vital  for preventing the occasional massive gradients from destabilizing training. We hinted that the exploding gradients stem from backpropagating across long sequences. Before introducing a slew of modern RNN architectures, let&#39;s take a closer look at how <em>backpropagation</em> works in sequence models in mathematical detail. Hopefully, this discussion will bring some precision  to the notion of <em>vanishing</em> and <em>exploding</em> gradients. If you recall our discussion of forward and backward  propagation through computational graphs when we introduced MLPs in :numref:<code>sec_backprop</code>, then forward propagation in RNNs should be relatively straightforward. Applying backpropagation in RNNs  is called <em>backpropagation through time</em> :cite:<code>Werbos.1990</code>. This procedure requires us to expand (or unroll)  the computational graph of an RNN one time step at a time. The unrolled RNN is essentially  a feedforward neural network  with the special property  that the same parameters  are repeated throughout the unrolled network, appearing at each time step. Then, just as in any feedforward neural network, we can apply the chain rule,  backpropagating gradients through the unrolled net. The gradient with respect to each parameter must be summed across all places  that the parameter occurs in the unrolled net. Handling such weight tying should be familiar  from our chapters on convolutional neural networks.</p><p>Complications arise because sequences can be rather long. It is not unusual to work with text sequences consisting of over a thousand tokens.  Note that this poses problems both from  a computational (too much memory) and optimization (numerical instability) standpoint.  Input from the first step passes through over 1000 matrix products before arriving at the output,  and another 1000 matrix products  are required to compute the gradient.  We now analyze what can go wrong and  how to address it in practice.</p><h2 id="Analysis-of-Gradients-in-RNNs"><a class="docs-heading-anchor" href="#Analysis-of-Gradients-in-RNNs">Analysis of Gradients in RNNs</a><a id="Analysis-of-Gradients-in-RNNs-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-of-Gradients-in-RNNs" title="Permalink"></a></h2><p>:label:<code>subsec_bptt_analysis</code></p><p>We start with a simplified model of how an RNN works. This model ignores details about the specifics  of the hidden state and how it is updated. The mathematical notation here does not explicitly distinguish scalars, vectors, and matrices. We are just trying to develop some intuition. In this simplified model, we denote <span>$h_t$</span> as the hidden state, <span>$x_t$</span> as input, and <span>$o_t$</span> as output at time step <span>$t$</span>. Recall our discussions in :numref:<code>subsec_rnn_w_hidden_states</code> that the input and the hidden state can be concatenated before being multiplied  by one weight variable in the hidden layer. Thus, we use <span>$w_\textrm{h}$</span> and <span>$w_\textrm{o}$</span> to indicate the weights  of the hidden layer and the output layer, respectively. As a result, the hidden states and outputs  at each time step are</p><p class="math-container">\[\begin{aligned}h_t &amp;= f(x_t, h_{t-1}, w_\textrm{h}),\\o_t &amp;= g(h_t, w_\textrm{o}),\end{aligned}\]</p><p>:eqlabel:<code>eq_bptt_ht_ot</code></p><p>where <span>$f$</span> and <span>$g$</span> are transformations of the hidden layer and the output layer, respectively. Hence, we have a chain of values  <span>$\{\ldots, (x_{t-1}, h_{t-1}, o_{t-1}), (x_{t}, h_{t}, o_t), \ldots\}$</span>  that depend on each other via recurrent computation. The forward propagation is fairly straightforward. All we need is to loop through the <span>$(x_t, h_t, o_t)$</span> triples one time step at a time. The discrepancy between output <span>$o_t$</span> and the desired target <span>$y_t$</span>  is then evaluated by an objective function  across all the <span>$T$</span> time steps as</p><p class="math-container">\[L(x_1, \ldots, x_T, y_1, \ldots, y_T, w_\textrm{h}, w_\textrm{o}) = \frac{1}{T}\sum_{t=1}^T l(y_t, o_t).\]</p><p>For backpropagation, matters are a bit trickier,  especially when we compute the gradients  with regard to the parameters <span>$w_\textrm{h}$</span> of the objective function <span>$L$</span>.  To be specific, by the chain rule,</p><p class="math-container">\[\begin{aligned}\frac{\partial L}{\partial w_\textrm{h}}  &amp; = \frac{1}{T}\sum_{t=1}^T \frac{\partial l(y_t, o_t)}{\partial w_\textrm{h}}  \\&amp; = \frac{1}{T}\sum_{t=1}^T \frac{\partial l(y_t, o_t)}{\partial o_t} \frac{\partial g(h_t, w_\textrm{o})}{\partial h_t}  \frac{\partial h_t}{\partial w_\textrm{h}}.\end{aligned}\]</p><p>:eqlabel:<code>eq_bptt_partial_L_wh</code></p><p>The first and the second factors of the product in :eqref:<code>eq_bptt_partial_L_wh</code> are easy to compute. The third factor <span>$\partial h_t/\partial w_\textrm{h}$</span> is where things get tricky,  since we need to recurrently compute the effect of the parameter <span>$w_\textrm{h}$</span> on <span>$h_t$</span>. According to the recurrent computation in :eqref:<code>eq_bptt_ht_ot</code>, <span>$h_t$</span> depends on both <span>$h_{t-1}$</span> and <span>$w_\textrm{h}$</span>, where computation of <span>$h_{t-1}$</span> also depends on <span>$w_\textrm{h}$</span>. Thus, evaluating the total derivate of <span>$h_t$</span>  with respect to <span>$w_\textrm{h}$</span> using the chain rule yields</p><p class="math-container">\[\frac{\partial h_t}{\partial w_\textrm{h}}= \frac{\partial f(x_{t},h_{t-1},w_\textrm{h})}{\partial w_\textrm{h}} +\frac{\partial f(x_{t},h_{t-1},w_\textrm{h})}{\partial h_{t-1}} \frac{\partial h_{t-1}}{\partial w_\textrm{h}}.\]</p><p>:eqlabel:<code>eq_bptt_partial_ht_wh_recur</code></p><p>To derive the above gradient, assume that we have  three sequences <span>$\{a_{t}\},\{b_{t}\},\{c_{t}\}$</span>  satisfying <span>$a_{0}=0$</span> and <span>$a_{t}=b_{t}+c_{t}a_{t-1}$</span> for <span>$t=1, 2,\ldots$</span>. Then for <span>$t\geq 1$</span>, it is easy to show</p><p class="math-container">\[a_{t}=b_{t}+\sum_{i=1}^{t-1}\left(\prod_{j=i+1}^{t}c_{j}\right)b_{i}.\]</p><p>:eqlabel:<code>eq_bptt_at</code></p><p>By substituting <span>$a_t$</span>, <span>$b_t$</span>, and <span>$c_t$</span> according to</p><p class="math-container">\[\begin{aligned}a_t &amp;= \frac{\partial h_t}{\partial w_\textrm{h}},\\
b_t &amp;= \frac{\partial f(x_{t},h_{t-1},w_\textrm{h})}{\partial w_\textrm{h}}, \\
c_t &amp;= \frac{\partial f(x_{t},h_{t-1},w_\textrm{h})}{\partial h_{t-1}},\end{aligned}\]</p><p>the gradient computation in :eqref:<code>eq_bptt_partial_ht_wh_recur</code> satisfies <span>$a_{t}=b_{t}+c_{t}a_{t-1}$</span>. Thus, per :eqref:<code>eq_bptt_at</code>,  we can remove the recurrent computation  in :eqref:<code>eq_bptt_partial_ht_wh_recur</code> with</p><p class="math-container">\[\frac{\partial h_t}{\partial w_\textrm{h}}=\frac{\partial f(x_{t},h_{t-1},w_\textrm{h})}{\partial w_\textrm{h}}+\sum_{i=1}^{t-1}\left(\prod_{j=i+1}^{t} \frac{\partial f(x_{j},h_{j-1},w_\textrm{h})}{\partial h_{j-1}} \right) \frac{\partial f(x_{i},h_{i-1},w_\textrm{h})}{\partial w_\textrm{h}}.\]</p><p>:eqlabel:<code>eq_bptt_partial_ht_wh_gen</code></p><p>While we can use the chain rule to compute <span>$\partial h_t/\partial w_\textrm{h}$</span> recursively,  this chain can get very long whenever <span>$t$</span> is large. Let&#39;s discuss a number of strategies for dealing with this problem.</p><h3 id="Full-Computation"><a class="docs-heading-anchor" href="#Full-Computation">Full Computation</a><a id="Full-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Computation" title="Permalink"></a></h3><p>One idea might be to compute the full sum in :eqref:<code>eq_bptt_partial_ht_wh_gen</code>. However, this is very slow and gradients can blow up, since subtle changes in the initial conditions can potentially affect the outcome a lot. That is, we could see things similar to the butterfly effect, where minimal changes in the initial conditions  lead to disproportionate changes in the outcome. This is generally undesirable. After all, we are looking for robust estimators that generalize well.  Hence this strategy is almost never used in practice.</p><h3 id="Truncating-Time-Steps###"><a class="docs-heading-anchor" href="#Truncating-Time-Steps###">Truncating Time Steps###</a><a id="Truncating-Time-Steps###-1"></a><a class="docs-heading-anchor-permalink" href="#Truncating-Time-Steps###" title="Permalink"></a></h3><p>Alternatively, we can truncate the sum in :eqref:<code>eq_bptt_partial_ht_wh_gen</code> after <span>$\tau$</span> steps.  This is what we have been discussing so far.  This leads to an <em>approximation</em> of the true gradient, simply by terminating the sum at <span>$\partial h_{t-\tau}/\partial w_\textrm{h}$</span>.  In practice this works quite well.  It is what is commonly referred to as truncated  backpropgation through time :cite:<code>Jaeger.2002</code>. One of the consequences of this is that the model  focuses primarily on short-term influence  rather than long-term consequences.  This is actually <em>desirable</em>, since it biases the estimate  towards simpler and more stable models.</p><h3 id="Randomized-Truncation"><a class="docs-heading-anchor" href="#Randomized-Truncation">Randomized Truncation</a><a id="Randomized-Truncation-1"></a><a class="docs-heading-anchor-permalink" href="#Randomized-Truncation" title="Permalink"></a></h3><p>Last, we can replace <span>$\partial h_t/\partial w_\textrm{h}$</span> by a random variable which is correct in expectation  but truncates the sequence. This is achieved by using a sequence of <span>$\xi_t$</span> with predefined <span>$0 \leq \pi_t \leq 1$</span>, where <span>$P(\xi_t = 0) = 1-\pi_t$</span> and  <span>$P(\xi_t = \pi_t^{-1}) = \pi_t$</span>, thus <span>$E[\xi_t] = 1$</span>. We use this to replace the gradient <span>$\partial h_t/\partial w_\textrm{h}$</span> in :eqref:<code>eq_bptt_partial_ht_wh_recur</code> with</p><p class="math-container">\[z_t= \frac{\partial f(x_{t},h_{t-1},w_\textrm{h})}{\partial w_\textrm{h}} +\xi_t \frac{\partial f(x_{t},h_{t-1},w_\textrm{h})}{\partial h_{t-1}} \frac{\partial h_{t-1}}{\partial w_\textrm{h}}.\]</p><p>It follows from the definition of <span>$\xi_t$</span>  that <span>$E[z_t] = \partial h_t/\partial w_\textrm{h}$</span>. Whenever <span>$\xi_t = 0$</span> the recurrent computation terminates at that time step <span>$t$</span>. This leads to a weighted sum of sequences of varying lengths, where long sequences are rare but appropriately overweighted.  This idea was proposed by  :citet:<code>Tallec.Ollivier.2017</code>.</p><h3 id="Comparing-Strategies"><a class="docs-heading-anchor" href="#Comparing-Strategies">Comparing Strategies</a><a id="Comparing-Strategies-1"></a><a class="docs-heading-anchor-permalink" href="#Comparing-Strategies" title="Permalink"></a></h3><p><img src="../../img/truncated-bptt.svg" alt="Comparing strategies for computing gradients in RNNs. From top to bottom: randomized truncation, regular truncation, and full computation."/> :label:<code>fig_truncated_bptt</code></p><p>:numref:<code>fig_truncated_bptt</code> illustrates the three strategies  when analyzing the first few characters of <em>The Time Machine</em>  using backpropagation through time for RNNs:</p><ul><li>The first row is the randomized truncation that partitions the text into segments of varying lengths.</li><li>The second row is the regular truncation that breaks the text into subsequences of the same length. This is what we have been doing in RNN experiments.</li><li>The third row is the full backpropagation through time that leads to a computationally infeasible expression.</li></ul><p>Unfortunately, while appealing in theory,  randomized truncation does not work  much better than regular truncation,  most likely due to a number of factors. First, the effect of an observation after a number of backpropagation steps  into the past is quite sufficient  to capture dependencies in practice.  Second, the increased variance counteracts the fact  that the gradient is more accurate with more steps.  Third, we actually <em>want</em> models that have only  a short range of interactions.  Hence, regularly truncated backpropagation through time  has a slight regularizing effect that can be desirable.</p><h2 id="Backpropagation-Through-Time-in-Detail"><a class="docs-heading-anchor" href="#Backpropagation-Through-Time-in-Detail">Backpropagation Through Time in Detail</a><a id="Backpropagation-Through-Time-in-Detail-1"></a><a class="docs-heading-anchor-permalink" href="#Backpropagation-Through-Time-in-Detail" title="Permalink"></a></h2><p>After discussing the general principle, let&#39;s discuss backpropagation through time in detail. In contrast to the analysis in :numref:<code>subsec_bptt_analysis</code>, in the following we will show how to compute the gradients of the objective function with respect to all the decomposed model parameters. To keep things simple, we consider  an RNN without bias parameters, whose activation function in the hidden layer uses the identity mapping (<span>$\phi(x)=x$</span>). For time step <span>$t$</span>, let the single example input  and the target be <span>$\mathbf{x}_t \in \mathbb{R}^d$</span> and <span>$y_t$</span>, respectively.  The hidden state <span>$\mathbf{h}_t \in \mathbb{R}^h$</span>  and the output <span>$\mathbf{o}_t \in \mathbb{R}^q$</span> are computed as</p><p class="math-container">\[\begin{aligned}\mathbf{h}_t &amp;= \mathbf{W}_\textrm{hx} \mathbf{x}_t + \mathbf{W}_\textrm{hh} \mathbf{h}_{t-1},\\
\mathbf{o}_t &amp;= \mathbf{W}_\textrm{qh} \mathbf{h}_{t},\end{aligned}\]</p><p>where <span>$\mathbf{W}_\textrm{hx} \in \mathbb{R}^{h \times d}$</span>, <span>$\mathbf{W}_\textrm{hh} \in \mathbb{R}^{h \times h}$</span>, and <span>$\mathbf{W}_\textrm{qh} \in \mathbb{R}^{q \times h}$</span> are the weight parameters. Denote by <span>$l(\mathbf{o}_t, y_t)$</span> the loss at time step <span>$t$</span>.  Our objective function, the loss over <span>$T$</span> time steps from the beginning of the sequence is thus</p><p class="math-container">\[L = \frac{1}{T} \sum_{t=1}^T l(\mathbf{o}_t, y_t).\]</p><p>In order to visualize the dependencies among model variables and parameters during computation of the RNN, we can draw a computational graph for the model, as shown in :numref:<code>fig_rnn_bptt</code>. For example, the computation of the hidden states of time step 3, <span>$\mathbf{h}_3$</span>, depends on the model parameters <span>$\mathbf{W}_\textrm{hx}$</span> and <span>$\mathbf{W}_\textrm{hh}$</span>, the hidden state of the previous time step <span>$\mathbf{h}_2$</span>, and the input of the current time step <span>$\mathbf{x}_3$</span>.</p><p><img src="../../img/rnn-bptt.svg" alt="Computational graph showing dependencies for an RNN model with three time steps. Boxes represent variables (not shaded) or parameters (shaded) and circles represent operators."/> :label:<code>fig_rnn_bptt</code></p><p>As just mentioned, the model parameters in :numref:<code>fig_rnn_bptt</code>  are <span>$\mathbf{W}_\textrm{hx}$</span>, <span>$\mathbf{W}_\textrm{hh}$</span>, and <span>$\mathbf{W}_\textrm{qh}$</span>.  Generally, training this model requires  gradient computation with respect to these parameters <span>$\partial L/\partial \mathbf{W}_\textrm{hx}$</span>, <span>$\partial L/\partial \mathbf{W}_\textrm{hh}$</span>, and <span>$\partial L/\partial \mathbf{W}_\textrm{qh}$</span>. According to the dependencies in :numref:<code>fig_rnn_bptt</code>, we can traverse in the opposite direction of the arrows to calculate and store the gradients in turn. To flexibly express the multiplication of  matrices, vectors, and scalars of different shapes in the chain rule, we continue to use the <span>$\textrm{prod}$</span> operator  as described in :numref:<code>sec_backprop</code>.</p><p>First of all, differentiating the objective function with respect to the model output at any time step <span>$t$</span> is fairly straightforward:</p><p class="math-container">\[\frac{\partial L}{\partial \mathbf{o}_t} =  \frac{\partial l (\mathbf{o}_t, y_t)}{T \cdot \partial \mathbf{o}_t} \in \mathbb{R}^q.\]</p><p>:eqlabel:<code>eq_bptt_partial_L_ot</code></p><p>Now we can calculate the gradient of the objective  with respect to the parameter <span>$\mathbf{W}_\textrm{qh}$</span> in the output layer: <span>$\partial L/\partial \mathbf{W}_\textrm{qh} \in \mathbb{R}^{q \times h}$</span>.  Based on :numref:<code>fig_rnn_bptt</code>,  the objective <span>$L$</span> depends on <span>$\mathbf{W}_\textrm{qh}$</span>  via <span>$\mathbf{o}_1, \ldots, \mathbf{o}_T$</span>.  Using the chain rule yields</p><p class="math-container">\[
\frac{\partial L}{\partial \mathbf{W}_\textrm{qh}}
= \sum_{t=1}^T \textrm{prod}\left(\frac{\partial L}{\partial \mathbf{o}_t}, \frac{\partial \mathbf{o}_t}{\partial \mathbf{W}_\textrm{qh}}\right)
= \sum_{t=1}^T \frac{\partial L}{\partial \mathbf{o}_t} \mathbf{h}_t^\top,
$$

where $\partial L/\partial \mathbf{o}_t$
is given by :eqref:`eq_bptt_partial_L_ot`.

Next, as shown in :numref:`fig_rnn_bptt`,
at the final time step $T$,
the objective function
$L$ depends on the hidden state $\mathbf{h}_T$ 
only via $\mathbf{o}_T$.
Therefore, we can easily find the gradient 
$\partial L/\partial \mathbf{h}_T \in \mathbb{R}^h$
using the chain rule:

$$\frac{\partial L}{\partial \mathbf{h}_T} = \textrm{prod}\left(\frac{\partial L}{\partial \mathbf{o}_T}, \frac{\partial \mathbf{o}_T}{\partial \mathbf{h}_T} \right) = \mathbf{W}_\textrm{qh}^\top \frac{\partial L}{\partial \mathbf{o}_T}.\]</p><p>:eqlabel:<code>eq_bptt_partial_L_hT_final_step</code></p><p>It gets trickier for any time step <span>$t &lt; T$</span>, where the objective function <span>$L$</span> depends on  <span>$\mathbf{h}_t$</span> via <span>$\mathbf{h}_{t+1}$</span> and <span>$\mathbf{o}_t$</span>. According to the chain rule, the gradient of the hidden state <span>$\partial L/\partial \mathbf{h}_t \in \mathbb{R}^h$</span> at any time step <span>$t &lt; T$</span> can be recurrently computed as:</p><p class="math-container">\[\frac{\partial L}{\partial \mathbf{h}_t} = \textrm{prod}\left(\frac{\partial L}{\partial \mathbf{h}_{t+1}}, \frac{\partial \mathbf{h}_{t+1}}{\partial \mathbf{h}_t} \right) + \textrm{prod}\left(\frac{\partial L}{\partial \mathbf{o}_t}, \frac{\partial \mathbf{o}_t}{\partial \mathbf{h}_t} \right) = \mathbf{W}_\textrm{hh}^\top \frac{\partial L}{\partial \mathbf{h}_{t+1}} + \mathbf{W}_\textrm{qh}^\top \frac{\partial L}{\partial \mathbf{o}_t}.\]</p><p>:eqlabel:<code>eq_bptt_partial_L_ht_recur</code></p><p>For analysis, expanding the recurrent computation for any time step <span>$1 \leq t \leq T$</span> gives</p><p class="math-container">\[\frac{\partial L}{\partial \mathbf{h}_t}= \sum_{i=t}^T {\left(\mathbf{W}_\textrm{hh}^\top\right)}^{T-i} \mathbf{W}_\textrm{qh}^\top \frac{\partial L}{\partial \mathbf{o}_{T+t-i}}.\]</p><p>:eqlabel:<code>eq_bptt_partial_L_ht</code></p><p>We can see from :eqref:<code>eq_bptt_partial_L_ht</code>  that this simple linear example already exhibits some key problems of long sequence models: it involves potentially very large powers of <span>$\mathbf{W}_\textrm{hh}^\top$</span>. In it, eigenvalues smaller than 1 vanish and eigenvalues larger than 1 diverge. This is numerically unstable, which manifests itself in the form of vanishing  and exploding gradients. One way to address this is to truncate the time steps at a computationally convenient size  as discussed in :numref:<code>subsec_bptt_analysis</code>.  In practice, this truncation can also be effected  by detaching the gradient after a given number of time steps. Later on, we will see how more sophisticated sequence models  such as long short-term memory can alleviate this further. </p><p>Finally, :numref:<code>fig_rnn_bptt</code> shows  that the objective function <span>$L$</span>  depends on model parameters <span>$\mathbf{W}_\textrm{hx}$</span> and <span>$\mathbf{W}_\textrm{hh}$</span> in the hidden layer via hidden states <span>$\mathbf{h}_1, \ldots, \mathbf{h}_T$</span>. To compute gradients with respect to such parameters <span>$\partial L / \partial \mathbf{W}_\textrm{hx} \in \mathbb{R}^{h \times d}$</span> and <span>$\partial L / \partial \mathbf{W}_\textrm{hh} \in \mathbb{R}^{h \times h}$</span>, we apply the chain rule giving</p><p>$</p><p>\begin{aligned} \frac{\partial L}{\partial \mathbf{W}<em>\textrm{hx}} &amp;= \sum</em>{t=1}^T \textrm{prod}\left(\frac{\partial L}{\partial \mathbf{h}<em>t}, \frac{\partial \mathbf{h}</em>t}{\partial \mathbf{W}<em>\textrm{hx}}\right) = \sum</em>{t=1}^T \frac{\partial L}{\partial \mathbf{h}<em>t} \mathbf{x}</em>t^\top,\
\frac{\partial L}{\partial \mathbf{W}<em>\textrm{hh}} &amp;= \sum</em>{t=1}^T \textrm{prod}\left(\frac{\partial L}{\partial \mathbf{h}<em>t}, \frac{\partial \mathbf{h}</em>t}{\partial \mathbf{W}<em>\textrm{hh}}\right) = \sum</em>{t=1}^T \frac{\partial L}{\partial \mathbf{h}<em>t} \mathbf{h}</em>{t-1}^\top, \end{aligned} $</p><p>where <span>$\partial L/\partial \mathbf{h}_t$</span> which is recurrently computed by :eqref:<code>eq_bptt_partial_L_hT_final_step</code> and :eqref:<code>eq_bptt_partial_L_ht_recur</code> is the key quantity that affects the numerical stability.</p><p>Since backpropagation through time is the application of backpropagation in RNNs, as we have explained in :numref:<code>sec_backprop</code>, training RNNs alternates forward propagation with backpropagation through time. Moreover, backpropagation through time computes and stores the above gradients in turn. Specifically, stored intermediate values are reused to avoid duplicate calculations, such as storing <span>$\partial L/\partial \mathbf{h}_t$</span> to be used in computation of both <span>$\partial L / \partial \mathbf{W}_\textrm{hx}$</span>  and <span>$\partial L / \partial \mathbf{W}_\textrm{hh}$</span>.</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>Backpropagation through time is merely an application of backpropagation to sequence models with a hidden state. Truncation, such as regular or randomized, is needed for computational convenience and numerical stability. High powers of matrices can lead to divergent or vanishing eigenvalues. This manifests itself in the form of exploding or vanishing gradients. For efficient computation, intermediate values are cached during backpropagation through time.</p><h2 id="Exercises"><a class="docs-heading-anchor" href="#Exercises">Exercises</a><a id="Exercises-1"></a><a class="docs-heading-anchor-permalink" href="#Exercises" title="Permalink"></a></h2><ol><li>Assume that we have a symmetric matrix <span>$\mathbf{M} \in \mathbb{R}^{n \times n}$</span> with eigenvalues <span>$\lambda_i$</span> whose corresponding eigenvectors are <span>$\mathbf{v}_i$</span> (<span>$i = 1, \ldots, n$</span>). Without loss of generality, assume that they are ordered in the order <span>$|\lambda_i| \geq |\lambda_{i+1}|$</span>. <ol><li>Show that <span>$\mathbf{M}^k$</span> has eigenvalues <span>$\lambda_i^k$</span>.</li><li>Prove that for a random vector <span>$\mathbf{x} \in \mathbb{R}^n$</span>, with high probability <span>$\mathbf{M}^k \mathbf{x}$</span> will be very much aligned with the eigenvector <span>$\mathbf{v}_1$</span> </li></ol></li></ol><p>of <span>$\mathbf{M}$</span>. Formalize this statement.</p><ol><li>What does the above result mean for gradients in RNNs?</li><li>Besides gradient clipping, can you think of any other methods to cope with gradient explosion in recurrent neural networks?</li></ol><pre><code class="language-julia hljs"></code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../RNN_6/">« Concise Implementation of Recurrent Neural Networks</a><a class="docs-footer-nextpage" href="../../CH9.Modern_Recurrent_Neural_Networks/MRNN7/">Sequence-to-Sequence Learning for Machine Translation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Sunday 15 June 2025 19:32">Sunday 15 June 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
